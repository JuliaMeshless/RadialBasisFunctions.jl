var documenterSearchIndex = {"docs":
[{"location":"theory/#Radial-Basis-Functions-Theory","page":"Theory","title":"Radial Basis Functions Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Radial Basis Functions (RBF) use only a distance (typically Euclidean) when constructing the basis. For example, if we wish to build an interpolator we get the following linear combination of RBFs","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f(mathbfx)=sum_i=1^N alpha_i phi(lvert mathbfx-mathbfx_i rvert)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mid cdot mid is a norm (we will use Euclidean from here on) and so lvert mathbfx-mathbfx_i rvert = r is the Euclidean distance (although it can be any) and N is the number of data points.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"There are several types of RBFs to choose from, some with a tunable shape parameter, varepsilon. Here are some popular ones:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Type Function\nPolyharmonic Spline phi(r) = r^n where n=1357dots\nMultiquadric phi(r)=sqrt (r varepsilon)^2+ 1 \nInverse Multiquadric phi(r) = frac1sqrt(r varepsilon)^2+1\nGaussian phi(r) = e^-(r varepsilon)^2","category":"page"},{"location":"theory/#Augmenting-with-Monomials","page":"Theory","title":"Augmenting with Monomials","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The interpolant may be augmented with a polynomial as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f(mathbfx)=sum_i=1^N alpha_i phi(lvert mathbfx-mathbfx_i rvert) + sum_i=1^N_p gamma_i p_i(mathbfx)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where N_p=beginpmatrix m+d  m endpmatrix is the number of monomials (m is the monomial order and d is the dimension of mathbfx) and p_i(mathbfx) is the monomial term, or:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_i(mathbfx)=q_i(lvert mathbfx-mathbfx_i rvert)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where q_i is the i-th monomial in mathbfq=beginbmatrix 1 x y x^2 xy y^2 endbmatrix in 2D, for example. By collocation the expansion of the augmented interpolant at all the nodes mathbfx_i where i=1dots N, there results a linear system for the interpolant weights as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginbmatrix\nmathbfA  mathbfP \nmathbfP^mathrmT  0\nendbmatrix\nbeginbmatrix\nboldsymbolalpha \nboldsymbolgamma\nendbmatrix=\nbeginbmatrix\nmathbff \n0\nendbmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfA=\nbeginbmatrix\nphi(lvert mathbfx_1-mathbfx_1 rvert)  dots  phi(lvert mathbfx_1-mathbfx_N rvert) \nvdots   vdots \nphi(lvert mathbfx_N-mathbfx_1 rvert)  dots  phi(lvert mathbfx_N-mathbfx_N rvert)\nendbmatrix\nhspace2em\nmathbfp=\nbeginbmatrix\np_1(mathbfx_1)  dots  p_N(mathbfx_1) \nvdots   vdots \np_1(mathbfx_N)  dots  p_N(mathbfx_N)\nendbmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and mathbff is the vector of dependent data points","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbff=\nbeginbmatrix\nf(mathbfx_1) \nvdots \nf(mathbfx_N)\nendbmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and boldsymbolalpha and boldsymbolgamma are the interpolation coefficients. Note that the equations relating to mathbfP^mathrmT are included to ensure optimal interpolation and unique solvability given that conditionally positive radial functions are used and the nodes in the subdomain form a unisolvent set. See (Fasshauer, et al. - Meshfree Approximation Methods with Matlab) and (Wendland, et al. - Scattered Data Approximation).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This augmentation of the system is highly encouraged for a couple main reasons:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Increased accuracy especially for flat fields and near boundaries\nTo ensure the linear system has a unique solution","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"See (Flyer, et al. - On the role of polynomials in RBF-FD approximations: I. Interpolation and accuracy) for more information on this.","category":"page"},{"location":"theory/#Local-Collocation","page":"Theory","title":"Local Collocation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The original RBF method employing the Kansa approach which connects all the nodes in the domain and, as such, is a global method. Due to ill-conditioning and computational cost, this approach scales poorly; therefore, a local approach is used instead. In the local approach, each node is influenced only by its k nearest neighbors which helps solve the issues related to global collocation.","category":"page"},{"location":"theory/#Constructing-an-Operator","page":"Theory","title":"Constructing an Operator","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the RBF-FD, a stencil is built to approximate derivatives using the same neighborhoods/subdomains of N points. For example, if mathcalL represents a linear differential operator, one can express the differentiation of the field variable u at the center of the subdomain mathbfx_c in terms of weights mathbfw_i and the field variable values on all the nodes within the subdomain as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathcalLu(mathbfx_c)=sum_i=1^Nw_iu(mathbfx_i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"m","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"After some algebraic manipulation and substitution using equations, one arrives at a linear system for the weights mathbfw as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginbmatrixmathbfA  mathbfP \nmathbfP^mathrmT  0\nendbmatrix\nbeginbmatrix\nmathbfw \nboldsymbollambda\nendbmatrix=\nbeginbmatrix\nmathcalLboldsymbolphi \nmathcalLmathbfp\nendbmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where boldsymbollambda are treated as Lagrange multipliers and are discarded after solving the linear system and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathcalLboldsymbolphi=\nbeginbmatrix\nmathcalLboldsymbolphi(lvert mathbfx_1-mathbfx_c rvert) \nvdots \nmathcalLboldsymbolphi(lvert mathbfx_N-mathbfx_c rvert)\nendbmatrix\nhspace2em\nmathcalLmathbfp=\nbeginbmatrix\nmathcalLmathbfp_1(mathbfx_c) \nvdots \nmathcalLmathbfp_N_p(mathbfx_c)\nendbmatrix","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, let's load the package along with the StaticArrays.jl package which we use for each data point","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using RadialBasisFunctions\nusing StaticArrays","category":"page"},{"location":"getting_started/#Interpolation","page":"Getting Started","title":"Interpolation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Suppose we have a set of data mathbfx where mathbfx_i in mathbbR^2, and we want to interpolate a function fmathbbR^2 rightarrow mathbbR","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"f(x) = 2*x[1]^2 + 3*x[2]\nx = [SVector{2}(rand(2)) for _ in 1:1000]\ny = f.(x)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and now we can build the interpolator","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"interp = RadialBasisInterp(x, y)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and evaluate it at a new point","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x_new = [rand(2) for _ in 1:5]\ny_new = interp(x_new)\ny_true = f.(x_new)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and compare the error","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"abs.(y_true .- y_new)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Wow! The error is numerically zero! Well... we set ourselves up for success here. RadialBasisInterp (along with RadialBasisOperator) has an optional argument to provide the type of radial basis including the degree of polynomial augmentation. The default basis is a cubic polyharmonic spline with 2nd degree polynomial augmentation (which the constructor is PHS(3, poly_deg=2)) and given the underlying function we are interpolating is a 2nd order polynomial itself, we are able to represent it exactly (up to machine precision). Let's see what happens when we only use 1st order polynomial augmentation","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"interp = RadialBasisInterp(x, y, PHS(3, poly_deg=1))\ny_new = interp(x_new)\nabs.(y_true .- y_new)","category":"page"},{"location":"getting_started/#Operators","page":"Getting Started","title":"Operators","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"more to come here...","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RadialBasisFunctions","category":"page"},{"location":"#RadialBasisFunctions.jl","page":"Home","title":"RadialBasisFunctions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RadialBasisFunctions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package intends to provide functions for all things regarding Radial Basis Functions (RBF). This includes","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interpolation\nLinear Operators\nPartial derivative (partial)\nLaplacian (nabla^2, Delta)\nGradient (nabla)\nSupport for custom / user supplied operators (mathcalL)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we support the following types of RBFs (all have polynomial augmentation by default, but is optional)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type Function, phi(r)\nPolyharmonic Spline r^n where n=1357\nInverse Multiquadric frac1sqrt(r varepsilon)^2+1\nGaussian e^-(r varepsilon)^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"where varepsilon is a user-supplied shape parameter.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply install the latest stable release using Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add RadialBasisFunctions","category":"page"},{"location":"#Planned-Features","page":"Home","title":"Planned Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adaptive operators and interpolation. Adding / removing / modifying points and automatically updating the weights without a complete recalculation.\nAdd more built-in operator combinations that will allow you to lazily construct operators such as\ndivergence\ncurl","category":"page"},{"location":"#Current-Limitations","page":"Home","title":"Current Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A critical dependency of this package is NearestNeighbors.jl which requires that the dimension of each data point is inferrable. To quote from NearestNeighbors.jl:\nThe data, i.e., the points to build up the tree from. It can either bea matrix of size nd × np with the points to insert in the tree where nd is the dimensionality of the points and np is the number of points\na vector of vectors with fixed dimensionality, nd, which must be part of the type. Specifically, data should be a Vector{V}, where V is itself a subtype of an AbstractVector and such that eltype(V) and length(V) are defined. (For example, with 3D points, V = SVector{3, Float64} works because eltype(V) = Float64 and length(V) = 3 are defined in V.)\nThat said, we currently only support the second option here (Vector{AbstractVector}), but plan to support matrix inputs in the future.\nRadialBasisInterp uses all points, but there are plans to support local collocation / subdomains like the operators use.","category":"page"}]
}
