import{_ as r,C as d,c as o,o as p,j as i,a as l,aA as n,G as t,w as e}from"./chunks/framework.N_e1-pUO.js";const Qi=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reference/api.md","filePath":"reference/api.md","lastUpdated":null}'),h={name:"reference/api.md"},u={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},H={class:"MathJax",jax:"SVG",overflow:"linebreak"},U={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.129ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 1825 1000"},G={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"3.409ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 1506.8 1000"},z={class:"jldocstring custom-block",open:""},W={class:"MathJax",jax:"SVG",overflow:"linebreak"},Z={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.129ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 1825 1000"},Q={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.397ex",height:"2.452ex",role:"img",focusable:"false",viewBox:"0 -833.9 1943.3 1083.9"},q={class:"jldocstring custom-block",open:""},K={class:"MathJax",jax:"SVG",overflow:"linebreak"},$={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.129ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 1825 1000"},X={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.397ex",height:"2.452ex",role:"img",focusable:"false",viewBox:"0 -833.9 1943.3 1083.9"},Y={class:"jldocstring custom-block",open:""},ss={class:"MathJax",jax:"SVG",overflow:"linebreak"},is={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.129ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 1825 1000"},as={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.397ex",height:"2.468ex",role:"img",focusable:"false",viewBox:"0 -841 1943.3 1091"},ts={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},_s={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},Bs={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},xs={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},Ds={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},Ss={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},ws={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},Ls={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Os={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},zs={class:"jldocstring custom-block",open:""},Ws={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},$s={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},si={class:"jldocstring custom-block",open:""},ii={class:"jldocstring custom-block",open:""},ai={class:"jldocstring custom-block",open:""},ti={class:"jldocstring custom-block",open:""},li={class:"jldocstring custom-block",open:""},ei={class:"jldocstring custom-block",open:""},ni={class:"jldocstring custom-block",open:""},oi={class:"jldocstring custom-block",open:""},pi={class:"jldocstring custom-block",open:""},ri={class:"jldocstring custom-block",open:""},di={class:"jldocstring custom-block",open:""},hi={class:"jldocstring custom-block",open:""},ui={class:"jldocstring custom-block",open:""},ki={class:"jldocstring custom-block",open:""},ci={class:"jldocstring custom-block",open:""},bi={class:"jldocstring custom-block",open:""},gi={class:"jldocstring custom-block",open:""},yi={class:"jldocstring custom-block",open:""},_i={class:"jldocstring custom-block",open:""},Ei={class:"jldocstring custom-block",open:""},Ci={class:"jldocstring custom-block",open:""},mi={class:"jldocstring custom-block",open:""},fi={class:"jldocstring custom-block",open:""},Ti={class:"jldocstring custom-block",open:""},Fi={class:"jldocstring custom-block",open:""},ji={class:"jldocstring custom-block",open:""},Ai={class:"jldocstring custom-block",open:""},Bi={class:"jldocstring custom-block",open:""},vi={class:"jldocstring custom-block",open:""},xi={class:"jldocstring custom-block",open:""},Ri={class:"jldocstring custom-block",open:""},Di={class:"jldocstring custom-block",open:""},Vi={class:"jldocstring custom-block",open:""},Si={class:"jldocstring custom-block",open:""},Mi={class:"jldocstring custom-block",open:""},wi={class:"jldocstring custom-block",open:""},Ii={class:"jldocstring custom-block",open:""},Li={class:"jldocstring custom-block",open:""},Pi={class:"jldocstring custom-block",open:""},Oi={class:"jldocstring custom-block",open:""},Ni={class:"jldocstring custom-block",open:""};function Ji(Hi,s,Ui,Gi,zi,Wi){const a=d("Badge");return p(),o("div",null,[s[517]||(s[517]=i("h2",{id:"Exported-Functions",tabindex:"-1"},[l("Exported Functions "),i("a",{class:"header-anchor",href:"#Exported-Functions","aria-label":'Permalink to "Exported Functions {#Exported-Functions}"'},"​")],-1)),i("details",u,[i("summary",null,[s[0]||(s[0]=i("a",{id:"RadialBasisFunctions.PHS-Union{Tuple{}, Tuple{T}} where T<:Int64",href:"#RadialBasisFunctions.PHS-Union{Tuple{}, Tuple{T}} where T<:Int64"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.PHS")],-1)),s[1]||(s[1]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[3]||(s[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Convienience contructor for polyharmonic splines.</p><p><strong>Arguments</strong></p><ul><li><p><code>n</code>: Order of the spline (1, 3, 5, or 7). Higher = smoother.</p></li><li><p><code>poly_deg</code>: Polynomial augmentation degree (default: 2 for quadratic).</p></li></ul><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.IMQ"><code>IMQ</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.Gaussian"><code>Gaussian</code></a></p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[2]||(s[2]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/polyharmonic_spline.jl#L10-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",k,[i("summary",null,[s[4]||(s[4]=i("a",{id:"RadialBasisFunctions.classify_stencil-Union{Tuple{T}, Tuple{Vector{Bool}, Array{BoundaryCondition{T}, 1}, Int64, Vector{Int64}, Vector{Int64}}} where T",href:"#RadialBasisFunctions.classify_stencil-Union{Tuple{T}, Tuple{Vector{Bool}, Array{BoundaryCondition{T}, 1}, Int64, Vector{Int64}, Vector{Int64}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.classify_stencil")],-1)),s[5]||(s[5]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[7]||(s[7]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">classify_stencil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(is_boundary, boundary_conditions, eval_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                neighbors, global_to_boundary)</span></span></code></pre></div><p>Classify stencil type for dispatch in kernel execution.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[6]||(s[6]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L166-L171",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",c,[i("summary",null,[s[8]||(s[8]=i("a",{id:"RadialBasisFunctions.custom-Tuple{AbstractVector, Function}",href:"#RadialBasisFunctions.custom-Tuple{AbstractVector, Function}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.custom")],-1)),s[9]||(s[9]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[11]||(s[11]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">custom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, ℒ; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, k, adjl, hermite)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> with a custom operator function.</p><p><strong>Arguments</strong></p><ul><li><p><code>data</code>: Vector of data points</p></li><li><p><code>ℒ</code>: Custom function that accepts a basis and returns a callable <code>(x, xᵢ) -&gt; value</code></p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Custom operator that returns the basis function itself</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> custom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, basis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x, xᵢ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> basis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, xᵢ))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Custom biharmonic operator (∇⁴)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> custom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, basis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ∇²</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">∘</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ∇²</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis))</span></span></code></pre></div>`,8)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[10]||(s[10]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/custom.jl#L13-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",b,[i("summary",null,[s[12]||(s[12]=i("a",{id:"RadialBasisFunctions.directional-Tuple{AbstractVector, AbstractVector}",href:"#RadialBasisFunctions.directional-Tuple{AbstractVector, AbstractVector}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.directional")],-1)),s[13]||(s[13]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[15]||(s[15]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">directional</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, v; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, k, adjl, hermite)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> for the directional derivative (∇f⋅v).</p><p><strong>Arguments</strong></p><ul><li><p><code>data</code>: Vector of data points</p></li><li><p><code>v</code>: Direction vector. Can be:</p><ul><li><p>A single vector of length <code>Dim</code> (constant direction)</p></li><li><p>A vector of vectors matching <code>length(data)</code> (spatially-varying direction)</p></li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Constant direction</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂_x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> directional</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Spatially-varying direction (e.g., radial)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">normals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂_n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> directional</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, normals)</span></span></code></pre></div><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.gradient-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>gradient</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.partial-Tuple{AbstractVector, Int64, Int64}"><code>partial</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.laplacian-Tuple{AbstractVector, AbstractVector, AbstractRadialBasis, Vector{Bool}, Vector{&lt;:BoundaryCondition}, Vector{&lt;:AbstractVector}}"><code>laplacian</code></a></p>`,9)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[14]||(s[14]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/directional.jl#L12-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",g,[i("summary",null,[s[16]||(s[16]=i("a",{id:"RadialBasisFunctions.gradient-Tuple{AbstractVector{<:AbstractVector}, Any}",href:"#RadialBasisFunctions.gradient-Tuple{AbstractVector{<:AbstractVector}, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.gradient")],-1)),s[17]||(s[17]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[19]||(s[19]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, x; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k, adjl)</span></span></code></pre></div><p>One-shot convenience function that creates a gradient operator and applies it to scalar field <code>x</code>.</p><p>For repeated evaluations, prefer creating the operator once with <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.gradient-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>gradient(data)</code></a>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(points, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∇u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points, u)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># One-shot gradient computation</span></span></code></pre></div>`,5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[18]||(s[18]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/gradient.jl#L68-L81",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",y,[i("summary",null,[s[20]||(s[20]=i("a",{id:"RadialBasisFunctions.gradient-Tuple{AbstractVector{<:AbstractVector}}",href:"#RadialBasisFunctions.gradient-Tuple{AbstractVector{<:AbstractVector}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.gradient")],-1)),s[21]||(s[21]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[23]||(s[23]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, k, adjl, hermite)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> for computing gradients of scalar fields.</p><p>This is a convenience alias for <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.jacobian-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>jacobian</code></a>. The gradient of a scalar field is mathematically the Jacobian (a 1×D row vector, returned as a length-D vector per point).</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Vector of points (e.g., <code>Vector{SVector{2,Float64}}</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis function (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(points, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∇u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Matrix (1000 × 2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂u_∂x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ∇u[:, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂u_∂y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ∇u[:, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.jacobian-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>jacobian</code></a></p>`,10)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[22]||(s[22]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/gradient.jl#L5-L35",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_,[i("summary",null,[s[24]||(s[24]=i("a",{id:"RadialBasisFunctions.jacobian-Tuple{AbstractVector{<:AbstractVector}, Any}",href:"#RadialBasisFunctions.jacobian-Tuple{AbstractVector{<:AbstractVector}, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.jacobian")],-1)),s[25]||(s[25]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[27]||(s[27]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">jacobian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, x; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k, adjl)</span></span></code></pre></div><p>One-shot convenience function that creates a Jacobian operator and applies it to field <code>x</code>.</p><p>For repeated evaluations on the same points, prefer creating the operator once with <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.jacobian-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>jacobian(data)</code></a> and calling it via functor syntax <code>op(x)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>data</code>: Vector of points</p></li><li><p><code>x</code>: Field values to differentiate</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis function (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(points, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∇u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jacobian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points, u)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># One-shot gradient computation</span></span></code></pre></div>`,9)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[26]||(s[26]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/jacobian.jl#L104-L127",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",E,[i("summary",null,[s[28]||(s[28]=i("a",{id:"RadialBasisFunctions.jacobian-Tuple{AbstractVector{<:AbstractVector}}",href:"#RadialBasisFunctions.jacobian-Tuple{AbstractVector{<:AbstractVector}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.jacobian")],-1)),s[29]||(s[29]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[31]||(s[31]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">jacobian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, k, adjl, hermite)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> for computing Jacobians (or gradients for scalar fields).</p><p>The Jacobian is the fundamental differential operator. For a scalar field, it computes the gradient. For a vector field, it computes the full Jacobian matrix. The spatial dimension is automatically inferred from the data.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Vector of points (e.g., <code>Vector{SVector{2,Float64}}</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis function (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jacobian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Scalar field → gradient</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(points, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∇u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Matrix (1000 × 2)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Vector field → Jacobian matrix</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(points, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">J </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Array (1000 × 2 × 2)</span></span></code></pre></div><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.gradient-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>gradient</code></a></p>`,10)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[30]||(s[30]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/jacobian.jl#L26-L60",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",C,[i("summary",null,[s[32]||(s[32]=i("a",{id:"RadialBasisFunctions.laplacian-Tuple{AbstractVector, AbstractVector, AbstractRadialBasis, Vector{Bool}, Vector{<:BoundaryCondition}, Vector{<:AbstractVector}}",href:"#RadialBasisFunctions.laplacian-Tuple{AbstractVector, AbstractVector, AbstractRadialBasis, Vector{Bool}, Vector{<:BoundaryCondition}, Vector{<:AbstractVector}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.laplacian")],-1)),s[33]||(s[33]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[35]||(s[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points, basis, is_boundary, boundary_conditions, normals; k, adjl)</span></span></code></pre></div><p>Build a Hermite-compatible <code>RadialBasisOperator</code> for the Laplacian. Maintains backward compatibility with the positional argument API.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[34]||(s[34]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/laplacian.jl#L56-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",m,[i("summary",null,[s[36]||(s[36]=i("a",{id:"RadialBasisFunctions.laplacian-Tuple{AbstractVector}",href:"#RadialBasisFunctions.laplacian-Tuple{AbstractVector}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.laplacian")],-1)),s[37]||(s[37]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[39]||(s[39]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, k, adjl, hermite)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> for the Laplacian operator (∇²f).</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Vector of data points</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Basic usage</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With custom basis</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With different evaluation points</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eval_pts)</span></span></code></pre></div><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.partial-Tuple{AbstractVector, Int64, Int64}"><code>partial</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.gradient-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>gradient</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.directional-Tuple{AbstractVector, AbstractVector}"><code>directional</code></a></p>`,9)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[38]||(s[38]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/laplacian.jl#L10-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",f,[i("summary",null,[s[40]||(s[40]=i("a",{id:"RadialBasisFunctions.partial-Tuple{AbstractVector, Int64, Int64}",href:"#RadialBasisFunctions.partial-Tuple{AbstractVector, Int64, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.partial")],-1)),s[41]||(s[41]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[43]||(s[43]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, order, dim; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, k, adjl, hermite)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> for a partial derivative.</p><p><strong>Arguments</strong></p><ul><li><p><code>data</code>: Vector of data points</p></li><li><p><code>order</code>: Derivative order (1 or 2)</p></li><li><p><code>dim</code>: Dimension index to differentiate</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># First derivative in x-direction</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Second derivative in y-direction</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂²y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.laplacian-Tuple{AbstractVector, AbstractVector, AbstractRadialBasis, Vector{Bool}, Vector{&lt;:BoundaryCondition}, Vector{&lt;:AbstractVector}}"><code>laplacian</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.gradient-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>gradient</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.directional-Tuple{AbstractVector, AbstractVector}"><code>directional</code></a></p>`,9)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[42]||(s[42]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/partial.jl#L13-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",T,[i("summary",null,[s[44]||(s[44]=i("a",{id:"RadialBasisFunctions.regrid-Tuple{AbstractVector, AbstractVector}",href:"#RadialBasisFunctions.regrid-Tuple{AbstractVector, AbstractVector}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.regrid")],-1)),s[45]||(s[45]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[47]||(s[47]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">regrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k, adjl)</span></span></code></pre></div><p>Build a <code>RadialBasisOperator</code> for interpolating from <code>data</code> points to <code>eval_points</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>data</code>: Source data points</p></li><li><p><code>eval_points</code>: Target evaluation points</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>basis</code>: RBF basis (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Interpolate from coarse grid to fine grid</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coarse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> regrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coarse, fine)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Apply to field values</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u_coarse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.(coarse, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u_fine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u_coarse)</span></span></code></pre></div><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.Interpolator"><code>Interpolator</code></a></p>`,9)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[46]||(s[46]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/regridding.jl#L13-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",F,[i("summary",null,[s[48]||(s[48]=i("a",{id:"RadialBasisFunctions.update_hermite_stencil_data!-Union{Tuple{T}, Tuple{HermiteStencilData{T}, AbstractVector{<:AbstractVector{T}}, Vector{Int64}, Vector{Bool}, Array{BoundaryCondition{T}, 1}, AbstractVector{<:AbstractVector{T}}, Vector{Int64}}} where T",href:"#RadialBasisFunctions.update_hermite_stencil_data!-Union{Tuple{T}, Tuple{HermiteStencilData{T}, AbstractVector{<:AbstractVector{T}}, Vector{Int64}, Vector{Bool}, Array{BoundaryCondition{T}, 1}, AbstractVector{<:AbstractVector{T}}, Vector{Int64}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.update_hermite_stencil_data!")],-1)),s[49]||(s[49]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[51]||(s[51]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_hermite_stencil_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hermite_data, global_data, neighbors,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                             is_boundary, boundary_conditions, normals,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                             global_to_boundary)</span></span></code></pre></div><p>Populate local Hermite stencil data from global arrays. Used within kernels to extract boundary info for specific neighborhoods.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[50]||(s[50]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L104-L111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",j,[i("summary",null,[s[52]||(s[52]=i("a",{id:"RadialBasisFunctions.∂virtual-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector, AbstractVector, Any, Any}, Tuple{AbstractVector, AbstractVector, Any, Any, B}} where {T<:Int64, B<:AbstractRadialBasis}",href:"#RadialBasisFunctions.∂virtual-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector, AbstractVector, Any, Any}, Tuple{AbstractVector, AbstractVector, Any, Any, B}} where {T<:Int64, B<:AbstractRadialBasis}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂virtual")],-1)),s[53]||(s[53]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[55]||(s[55]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ∂virtual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points, dim, Δ, basis; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">autoselect_k</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, basis))</span></span></code></pre></div><p>Builds a virtual <code>RadialBasisOperator</code> whichi will be evaluated at <code>eval_points</code> where the operator is the partial derivative with respect to <code>dim</code>. Virtual operators interpolate the data to structured points at a distance <code>Δ</code> for which standard finite difference formulas can be applied.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[54]||(s[54]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/virtual.jl#L2-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",A,[i("summary",null,[s[56]||(s[56]=i("a",{id:"RadialBasisFunctions.∂virtual-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector, Any, Any}, Tuple{AbstractVector, Any, Any, B}} where {T<:Int64, B<:AbstractRadialBasis}",href:"#RadialBasisFunctions.∂virtual-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector, Any, Any}, Tuple{AbstractVector, Any, Any, B}} where {T<:Int64, B<:AbstractRadialBasis}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂virtual")],-1)),s[57]||(s[57]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[59]||(s[59]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ∂virtual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, dim, Δ, basis; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">autoselect_k</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, basis))</span></span></code></pre></div><p>Builds a virtual <code>RadialBasisOperator</code> whichi will be evaluated at the input points (<code>data</code>) where the operator is the partial derivative with respect to <code>dim</code>. Virtual operators interpolate the data to structured points at a distance <code>Δ</code> for which standard finite difference formulas can be applied.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[58]||(s[58]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/virtual.jl#L39-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",B,[i("summary",null,[s[60]||(s[60]=i("a",{id:"RadialBasisFunctions.AbstractPHS",href:"#RadialBasisFunctions.AbstractPHS"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.AbstractPHS")],-1)),s[61]||(s[61]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[63]||(s[63]=i("p",null,"abstract type AbstractPHS <: AbstractRadialBasis",-1)),s[64]||(s[64]=i("p",null,"Supertype of all Polyharmonic Splines.",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[62]||(s[62]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/polyharmonic_spline.jl#L3-L7",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",v,[i("summary",null,[s[65]||(s[65]=i("a",{id:"RadialBasisFunctions.AbstractRadialBasis",href:"#RadialBasisFunctions.AbstractRadialBasis"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.AbstractRadialBasis")],-1)),s[66]||(s[66]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[68]||(s[68]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractRadialBasis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBasis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span></span></code></pre></div>',1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[67]||(s[67]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L6-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",x,[i("summary",null,[s[69]||(s[69]=i("a",{id:"RadialBasisFunctions.BoundaryCondition",href:"#RadialBasisFunctions.BoundaryCondition"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.BoundaryCondition")],-1)),s[70]||(s[70]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[72]||(s[72]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BoundaryCondition{T}</span></span></code></pre></div><p>Unified boundary condition representation: Bu = α_u + β_∂ₙu</p><p>Special cases:</p><ul><li><p>Dirichlet: α=1, β=0</p></li><li><p>Neumann: α=0, β=1</p></li><li><p>Robin: α≠0, β≠0</p></li><li><p>Internal: α=0, β=0 (sentinel for interior points)</p></li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[71]||(s[71]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L7-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",R,[i("summary",null,[s[73]||(s[73]=i("a",{id:"RadialBasisFunctions.Custom",href:"#RadialBasisFunctions.Custom"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Custom")],-1)),s[74]||(s[74]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[76]||(s[76]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Custom{F</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractOperator</span></span></code></pre></div><p>Custom operator that applies a user-defined function to basis functions. The function <code>ℒ</code> should accept a basis and return a callable <code>(x, xᵢ) -&gt; value</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[75]||(s[75]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/custom.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",D,[i("summary",null,[s[77]||(s[77]=i("a",{id:"RadialBasisFunctions.Directional",href:"#RadialBasisFunctions.Directional"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Directional")],-1)),s[78]||(s[78]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[80]||(s[80]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Directional{Dim,T} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ScalarValuedOperator</span></span></code></pre></div><p>Operator for the directional derivative (∇f⋅v), the inner product of the gradient and a direction vector.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[79]||(s[79]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/directional.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",V,[i("summary",null,[s[81]||(s[81]=i("a",{id:"RadialBasisFunctions.Gaussian",href:"#RadialBasisFunctions.Gaussian"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Gaussian")],-1)),s[82]||(s[82]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[84]||(s[84]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gaussian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ε</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gaussian radial basis function: <code>ϕ(r) = exp(-(εr)²)</code></p><p><strong>Arguments</strong></p><ul><li><p><code>ε</code>: Shape parameter (must be &gt; 0). Smaller values = wider basis.</p></li><li><p><code>poly_deg</code>: Polynomial augmentation degree (default: 2).</p></li></ul><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.PHS-Union{Tuple{}, Tuple{T}} where T&lt;:Int64"><code>PHS</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.IMQ"><code>IMQ</code></a></p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[83]||(s[83]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/gaussian.jl#L1-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",S,[i("summary",null,[s[85]||(s[85]=i("a",{id:"RadialBasisFunctions.HermiteStencilData",href:"#RadialBasisFunctions.HermiteStencilData"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.HermiteStencilData")],-1)),s[86]||(s[86]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[88]||(s[88]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HermiteStencilData{T}</span></span></code></pre></div><p>Local stencil data for Hermite interpolation with boundary conditions.</p><p>Fields:</p><ul><li><p><code>data</code>: Coordinates of k stencil points</p></li><li><p><code>is_boundary</code>: Boolean flags for each point</p></li><li><p><code>boundary_conditions</code>: BC for each point (use Internal() for interior)</p></li><li><p><code>normals</code>: Normal vectors (zero for interior points)</p></li><li><p><code>poly_workspace</code>: Pre-allocated buffer for polynomial operations (avoids allocations in hot path)</p></li></ul><p>Note: For interior points (is_boundary[i] == false), boundary_conditions[i] and normals[i] contain sentinel values and should not be accessed.</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[87]||(s[87]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L48-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",M,[i("summary",null,[s[89]||(s[89]=i("a",{id:"RadialBasisFunctions.HermiteStencilData-Union{Tuple{Int64, Int64}, Tuple{Int64, Int64, Int64}, Tuple{T}} where T<:Real",href:"#RadialBasisFunctions.HermiteStencilData-Union{Tuple{Int64, Int64}, Tuple{Int64, Int64, Int64}, Tuple{T}} where T<:Real"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.HermiteStencilData")],-1)),s[90]||(s[90]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[92]||(s[92]=i("p",null,"Pre-allocation constructor for HermiteStencilData",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[91]||(s[91]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",w,[i("summary",null,[s[93]||(s[93]=i("a",{id:"RadialBasisFunctions.IMQ",href:"#RadialBasisFunctions.IMQ"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.IMQ")],-1)),s[94]||(s[94]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[96]||(s[96]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IMQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ε</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Inverse Multiquadric radial basis function: <code>ϕ(r) = 1/√((εr)² + 1)</code></p><p><strong>Arguments</strong></p><ul><li><p><code>ε</code>: Shape parameter (must be &gt; 0). Smaller values = flatter basis.</p></li><li><p><code>poly_deg</code>: Polynomial augmentation degree (default: 2).</p></li></ul><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.PHS-Union{Tuple{}, Tuple{T}} where T&lt;:Int64"><code>PHS</code></a>, <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.Gaussian"><code>Gaussian</code></a></p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[95]||(s[95]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/inverse_multiquadric.jl#L4-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",I,[i("summary",null,[s[97]||(s[97]=i("a",{id:"RadialBasisFunctions.Interpolator",href:"#RadialBasisFunctions.Interpolator"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Interpolator")],-1)),s[98]||(s[98]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[100]||(s[100]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Interpolator</span></span></code></pre></div><p>Construct a radial basis interpolation.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[99]||(s[99]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/interpolation.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",L,[i("summary",null,[s[101]||(s[101]=i("a",{id:"RadialBasisFunctions.Interpolator-Union{Tuple{B}, Tuple{Any, Any}, Tuple{Any, Any, B}} where B<:AbstractRadialBasis",href:"#RadialBasisFunctions.Interpolator-Union{Tuple{B}, Tuple{Any, Any}, Tuple{Any, Any, B}} where B<:AbstractRadialBasis"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Interpolator")],-1)),s[102]||(s[102]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[104]||(s[104]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Interpolator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Construct a radial basis interpolator.</p><p>See also: <a href="/RadialBasisFunctions.jl/v0.3/reference/api#RadialBasisFunctions.regrid-Tuple{AbstractVector, AbstractVector}"><code>regrid</code></a> for local stencil-based interpolation between point sets.</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[103]||(s[103]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/interpolation.jl#L15-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",P,[i("summary",null,[s[105]||(s[105]=i("a",{id:"RadialBasisFunctions.Jacobian",href:"#RadialBasisFunctions.Jacobian"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Jacobian")],-1)),s[106]||(s[106]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[108]||(s[108]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Jacobian{Dim} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> VectorValuedOperator</span></span></code></pre></div><p>Operator type for computing Jacobians (and gradients as a special case).</p><p>The Jacobian is the fundamental differential operator that computes all partial derivatives. When applied to a scalar field, it produces the gradient. When applied to a vector field, it produces the full Jacobian matrix.</p><p>Differentiation increases tensor rank by 1. The output gains a trailing dimension of size D (the spatial dimension).</p><p><strong>Input/Output Shapes</strong></p><ul><li><p>Scalar field <code>Vector{T}</code> (N,) → Gradient <code>Matrix{T}</code> (N_eval × D)</p></li><li><p>Vector field <code>Matrix{T}</code> (N × D) → Jacobian <code>Array{T,3}</code> (N_eval × D × D)</p></li><li><p>Matrix field <code>Array{T,3}</code> (N × D × D) → 3-tensor <code>Array{T,4}</code> (N_eval × D × D × D)</p></li><li><p>General: input shape <code>(N, dims...)</code> → output shape <code>(N_eval, dims..., D)</code></p></li></ul>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[107]||(s[107]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/jacobian.jl#L1-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",O,[i("summary",null,[s[109]||(s[109]=i("a",{id:"RadialBasisFunctions.Laplacian",href:"#RadialBasisFunctions.Laplacian"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Laplacian")],-1)),s[110]||(s[110]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[112]||(s[112]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Laplacian </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ScalarValuedOperator</span></span></code></pre></div><p>Operator for the sum of the second derivatives w.r.t. each independent variable (∇²f).</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[111]||(s[111]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/laplacian.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",N,[i("summary",null,[s[113]||(s[113]=i("a",{id:"RadialBasisFunctions.MonomialBasis",href:"#RadialBasisFunctions.MonomialBasis"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.MonomialBasis")],-1)),s[114]||(s[114]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[116]||(s[116]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MonomialBasis{Dim,Deg} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBasis</span></span></code></pre></div><p><code>Dim</code> dimensional monomial basis of order <code>Deg</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[115]||(s[115]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/monomial.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",J,[i("summary",null,[s[117]||(s[117]=i("a",{id:"RadialBasisFunctions.PHS1",href:"#RadialBasisFunctions.PHS1"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.PHS1")],-1)),s[118]||(s[118]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[124]||(s[124]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PHS1{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPHS</span></span></code></pre></div>',1)),i("p",null,[s[122]||(s[122]=l("Polyharmonic spline radial basis function:",-1)),i("mjx-container",H,[(p(),o("svg",U,[...s[119]||(s[119]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r"><g data-mml-node="mi" data-latex="ϕ"><path data-c="1D719" d="M385 445C404 524 424 601 442 680L442 683C439 690 434 694 426 694C417 694 411 686 408 671L351 445C276 442 208 414 147 362C82 307 49 243 49 170C49 62 132-7 237-13C218-92 204-149 195-183C194-186 194-189 194-190C194-200 199-205 210-205C221-205 224-199 227-187L271-14C346-11 414 17 475 69C540 125 573 189 573 262C573 369 488 436 385 445M377 415C453 410 501 363 501 283C501 243 492 203 474 164C442 92 369 26 278 17M121 149C121 189 130 229 148 268C180 340 253 405 343 415L244 16C169 22 121 69 121 149Z"></path></g><g data-mml-node="mo" data-latex="(" transform="translate(596,0)"><path data-c="28" d="M318-248C327-248 332-243 332-234C332-231 330-227 327-223C275-183 233-117 202-26C175 53 161 131 161 208L161 292C161 369 175 447 202 526C233 617 275 683 327 723C330 726 332 730 332 734C332 743 327 748 318 748C317 748 314 747 311 745C251 699 201 631 160 540C121 453 101 371 101 292L101 208C101 129 121 47 160-40C201-131 251-199 311-245C314-247 317-248 318-248Z"></path></g><g data-mml-node="mi" data-latex="r" transform="translate(985,0)"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mo" data-latex=")" transform="translate(1436,0)"><path data-c="29" d="M78-245C138-199 188-131 229-40C268 47 288 129 288 208L288 292C288 371 268 453 229 540C188 631 138 699 78 745C75 747 72 748 71 748C62 748 57 743 57 734C57 730 59 726 62 723C114 683 156 617 187 526C214 447 228 369 228 292L228 208C228 131 214 53 187-26C156-117 114-183 62-223C59-227 57-231 57-234C57-243 62-248 71-248C72-248 75-247 78-245Z"></path></g></g></g>',1)])])),s[121]||(s[121]=i("mjx-break",{size:"4"}," ",-1)),(p(),o("svg",G,[...s[120]||(s[120]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r"><g data-mml-node="mo" data-latex="="><path data-c="3D" d="M698 367L80 367C64 367 56 359 56 344C56 329 64 321 80 321L698 321C714 321 722 329 722 344C722 356 711 367 698 367M698 179L80 179C64 179 56 171 56 156C56 141 64 133 80 133L698 133C714 133 722 141 722 156C722 169 711 179 698 179Z"></path></g><g data-mml-node="mi" data-latex="r" transform="translate(1055.8,0)"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g></g></g>',1)])]))])]),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[123]||(s[123]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/polyharmonic_spline.jl#L38-L42",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",z,[i("summary",null,[s[125]||(s[125]=i("a",{id:"RadialBasisFunctions.PHS3",href:"#RadialBasisFunctions.PHS3"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.PHS3")],-1)),s[126]||(s[126]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[132]||(s[132]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PHS3{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPHS</span></span></code></pre></div>',1)),i("p",null,[s[130]||(s[130]=l("Polyharmonic spline radial basis function:",-1)),i("mjx-container",W,[(p(),o("svg",Z,[...s[127]||(s[127]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r^3"><g data-mml-node="mi" data-latex="ϕ"><path data-c="1D719" d="M385 445C404 524 424 601 442 680L442 683C439 690 434 694 426 694C417 694 411 686 408 671L351 445C276 442 208 414 147 362C82 307 49 243 49 170C49 62 132-7 237-13C218-92 204-149 195-183C194-186 194-189 194-190C194-200 199-205 210-205C221-205 224-199 227-187L271-14C346-11 414 17 475 69C540 125 573 189 573 262C573 369 488 436 385 445M377 415C453 410 501 363 501 283C501 243 492 203 474 164C442 92 369 26 278 17M121 149C121 189 130 229 148 268C180 340 253 405 343 415L244 16C169 22 121 69 121 149Z"></path></g><g data-mml-node="mo" data-latex="(" transform="translate(596,0)"><path data-c="28" d="M318-248C327-248 332-243 332-234C332-231 330-227 327-223C275-183 233-117 202-26C175 53 161 131 161 208L161 292C161 369 175 447 202 526C233 617 275 683 327 723C330 726 332 730 332 734C332 743 327 748 318 748C317 748 314 747 311 745C251 699 201 631 160 540C121 453 101 371 101 292L101 208C101 129 121 47 160-40C201-131 251-199 311-245C314-247 317-248 318-248Z"></path></g><g data-mml-node="mi" data-latex="r" transform="translate(985,0)"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mo" data-latex=")" transform="translate(1436,0)"><path data-c="29" d="M78-245C138-199 188-131 229-40C268 47 288 129 288 208L288 292C288 371 268 453 229 540C188 631 138 699 78 745C75 747 72 748 71 748C62 748 57 743 57 734C57 730 59 726 62 723C114 683 156 617 187 526C214 447 228 369 228 292L228 208C228 131 214 53 187-26C156-117 114-183 62-223C59-227 57-231 57-234C57-243 62-248 71-248C72-248 75-247 78-245Z"></path></g></g></g>',1)])])),s[129]||(s[129]=i("mjx-break",{size:"4"}," ",-1)),(p(),o("svg",Q,[...s[128]||(s[128]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r^3"><g data-mml-node="mo" data-latex="="><path data-c="3D" d="M698 367L80 367C64 367 56 359 56 344C56 329 64 321 80 321L698 321C714 321 722 329 722 344C722 356 711 367 698 367M698 179L80 179C64 179 56 171 56 156C56 141 64 133 80 133L698 133C714 133 722 141 722 156C722 169 711 179 698 179Z"></path></g><g data-mml-node="msup" data-latex="r^3" transform="translate(1055.8,0)"><g data-mml-node="mi" data-latex="r"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mn" transform="translate(484,363) scale(0.707)" data-latex="3"><path data-c="33" d="M303 353C369 378 431 441 431 526C431 569 410 604 369 631C333 654 292 666 246 666C201 666 162 654 127 631C88 605 68 571 68 528C68 495 90 472 122 472C154 472 176 495 176 527C176 560 157 578 119 580C145 615 186 633 242 633C302 633 332 598 332 527C332 485 324 450 309 421C282 373 245 364 183 364C171 362 165 357 165 348C165 333 172 333 192 333L235 333C310 333 348 280 348 173C348 88 317 14 241 14C176 14 128 36 99 80C134 79 160 105 160 139C160 173 135 198 101 198C62 198 42 178 42 137C42 88 64 49 108 18C147-9 193-22 244-22C301-22 350-3 393 34C436 71 457 117 457 173C457 267 383 332 303 353Z"></path></g></g></g></g>',1)])]))])]),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[131]||(s[131]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/polyharmonic_spline.jl#L137-L141",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",q,[i("summary",null,[s[133]||(s[133]=i("a",{id:"RadialBasisFunctions.PHS5",href:"#RadialBasisFunctions.PHS5"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.PHS5")],-1)),s[134]||(s[134]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[140]||(s[140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PHS5{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPHS</span></span></code></pre></div>',1)),i("p",null,[s[138]||(s[138]=l("Polyharmonic spline radial basis function:",-1)),i("mjx-container",K,[(p(),o("svg",$,[...s[135]||(s[135]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r^5"><g data-mml-node="mi" data-latex="ϕ"><path data-c="1D719" d="M385 445C404 524 424 601 442 680L442 683C439 690 434 694 426 694C417 694 411 686 408 671L351 445C276 442 208 414 147 362C82 307 49 243 49 170C49 62 132-7 237-13C218-92 204-149 195-183C194-186 194-189 194-190C194-200 199-205 210-205C221-205 224-199 227-187L271-14C346-11 414 17 475 69C540 125 573 189 573 262C573 369 488 436 385 445M377 415C453 410 501 363 501 283C501 243 492 203 474 164C442 92 369 26 278 17M121 149C121 189 130 229 148 268C180 340 253 405 343 415L244 16C169 22 121 69 121 149Z"></path></g><g data-mml-node="mo" data-latex="(" transform="translate(596,0)"><path data-c="28" d="M318-248C327-248 332-243 332-234C332-231 330-227 327-223C275-183 233-117 202-26C175 53 161 131 161 208L161 292C161 369 175 447 202 526C233 617 275 683 327 723C330 726 332 730 332 734C332 743 327 748 318 748C317 748 314 747 311 745C251 699 201 631 160 540C121 453 101 371 101 292L101 208C101 129 121 47 160-40C201-131 251-199 311-245C314-247 317-248 318-248Z"></path></g><g data-mml-node="mi" data-latex="r" transform="translate(985,0)"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mo" data-latex=")" transform="translate(1436,0)"><path data-c="29" d="M78-245C138-199 188-131 229-40C268 47 288 129 288 208L288 292C288 371 268 453 229 540C188 631 138 699 78 745C75 747 72 748 71 748C62 748 57 743 57 734C57 730 59 726 62 723C114 683 156 617 187 526C214 447 228 369 228 292L228 208C228 131 214 53 187-26C156-117 114-183 62-223C59-227 57-231 57-234C57-243 62-248 71-248C72-248 75-247 78-245Z"></path></g></g></g>',1)])])),s[137]||(s[137]=i("mjx-break",{size:"4"}," ",-1)),(p(),o("svg",X,[...s[136]||(s[136]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r^5"><g data-mml-node="mo" data-latex="="><path data-c="3D" d="M698 367L80 367C64 367 56 359 56 344C56 329 64 321 80 321L698 321C714 321 722 329 722 344C722 356 711 367 698 367M698 179L80 179C64 179 56 171 56 156C56 141 64 133 80 133L698 133C714 133 722 141 722 156C722 169 711 179 698 179Z"></path></g><g data-mml-node="msup" data-latex="r^5" transform="translate(1055.8,0)"><g data-mml-node="mi" data-latex="r"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mn" transform="translate(484,363) scale(0.707)" data-latex="5"><path data-c="35" d="M118 315C123 315 129 319 134 326C164 371 205 393 257 393C292 393 319 373 337 332C348 305 354 264 354 209C354 146 346 102 331 76C306 35 272 14 229 14C162 14 109 62 91 114C94 113 96 114 100 114C130 114 155 137 155 167C155 198 130 219 100 219C65 219 50 200 50 163C50 63 131-22 231-22C292-22 344 0 386 44C428 88 449 141 449 202C449 260 432 310 398 353C361 400 315 423 259 423C212 423 171 408 138 378L138 556C165 548 191 544 218 544C264 544 304 555 338 578C369 597 390 616 402 634C408 642 411 648 411 651C411 661 406 666 396 666C341 645 294 634 256 634C211 634 168 643 127 662C122 664 118 665 114 665C105 665 100 656 100 637L100 345C100 324 100 315 118 315Z"></path></g></g></g></g>',1)])]))])]),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[139]||(s[139]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/polyharmonic_spline.jl#L237-L241",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Y,[i("summary",null,[s[141]||(s[141]=i("a",{id:"RadialBasisFunctions.PHS7",href:"#RadialBasisFunctions.PHS7"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.PHS7")],-1)),s[142]||(s[142]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[148]||(s[148]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PHS7{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractPHS</span></span></code></pre></div>',1)),i("p",null,[s[146]||(s[146]=l("Polyharmonic spline radial basis function:",-1)),i("mjx-container",ss,[(p(),o("svg",is,[...s[143]||(s[143]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r^7"><g data-mml-node="mi" data-latex="ϕ"><path data-c="1D719" d="M385 445C404 524 424 601 442 680L442 683C439 690 434 694 426 694C417 694 411 686 408 671L351 445C276 442 208 414 147 362C82 307 49 243 49 170C49 62 132-7 237-13C218-92 204-149 195-183C194-186 194-189 194-190C194-200 199-205 210-205C221-205 224-199 227-187L271-14C346-11 414 17 475 69C540 125 573 189 573 262C573 369 488 436 385 445M377 415C453 410 501 363 501 283C501 243 492 203 474 164C442 92 369 26 278 17M121 149C121 189 130 229 148 268C180 340 253 405 343 415L244 16C169 22 121 69 121 149Z"></path></g><g data-mml-node="mo" data-latex="(" transform="translate(596,0)"><path data-c="28" d="M318-248C327-248 332-243 332-234C332-231 330-227 327-223C275-183 233-117 202-26C175 53 161 131 161 208L161 292C161 369 175 447 202 526C233 617 275 683 327 723C330 726 332 730 332 734C332 743 327 748 318 748C317 748 314 747 311 745C251 699 201 631 160 540C121 453 101 371 101 292L101 208C101 129 121 47 160-40C201-131 251-199 311-245C314-247 317-248 318-248Z"></path></g><g data-mml-node="mi" data-latex="r" transform="translate(985,0)"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mo" data-latex=")" transform="translate(1436,0)"><path data-c="29" d="M78-245C138-199 188-131 229-40C268 47 288 129 288 208L288 292C288 371 268 453 229 540C188 631 138 699 78 745C75 747 72 748 71 748C62 748 57 743 57 734C57 730 59 726 62 723C114 683 156 617 187 526C214 447 228 369 228 292L228 208C228 131 214 53 187-26C156-117 114-183 62-223C59-227 57-231 57-234C57-243 62-248 71-248C72-248 75-247 78-245Z"></path></g></g></g>',1)])])),s[145]||(s[145]=i("mjx-break",{size:"4"}," ",-1)),(p(),o("svg",as,[...s[144]||(s[144]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math" data-latex="ϕ(r) = r^7"><g data-mml-node="mo" data-latex="="><path data-c="3D" d="M698 367L80 367C64 367 56 359 56 344C56 329 64 321 80 321L698 321C714 321 722 329 722 344C722 356 711 367 698 367M698 179L80 179C64 179 56 171 56 156C56 141 64 133 80 133L698 133C714 133 722 141 722 156C722 169 711 179 698 179Z"></path></g><g data-mml-node="msup" data-latex="r^7" transform="translate(1055.8,0)"><g data-mml-node="mi" data-latex="r"><path data-c="1D45F" d="M436 374C436 416 395 442 351 442C302 442 261 419 227 372C217 411 183 442 136 442C95 442 65 410 44 345C34 312 29 293 29 287C29 278 34 273 45 273C50 273 53 274 56 276C61 285 64 292 65 299C83 375 106 413 133 413C150 413 159 399 159 371C159 358 154 331 144 290L87 63C84 50 78 24 78 19C78-1 89-11 110-11C130-11 143-1 150 19L169 91C180 134 187 162 190 175L221 303C223 311 231 324 244 343C271 381 302 413 351 413C363 413 373 411 382 406C352 397 337 378 337 351C337 325 351 312 378 312C411 312 436 341 436 374Z"></path></g><g data-mml-node="mn" transform="translate(484,363) scale(0.707)" data-latex="7"><path data-c="37" d="M475 604C482 613 485 626 485 644L243 644C174 644 135 648 128 657C125 660 122 667 120 676L89 676L55 464L88 464C98 520 106 550 112 555C115 558 146 560 205 560L401 560L295 410C214 295 174 171 174 36C174-3 190-22 223-22C256-22 272-3 272 36L272 87C272 239 296 349 343 416Z"></path></g></g></g></g>',1)])]))])]),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[147]||(s[147]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/polyharmonic_spline.jl#L336-L340",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ts,[i("summary",null,[s[149]||(s[149]=i("a",{id:"RadialBasisFunctions.Partial",href:"#RadialBasisFunctions.Partial"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Partial")],-1)),s[150]||(s[150]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[152]||(s[152]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Partial{T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ScalarValuedOperator</span></span></code></pre></div><p>Operator for a partial derivative of specified order with respect to a dimension.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[151]||(s[151]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/partial.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ls,[i("summary",null,[s[153]||(s[153]=i("a",{id:"RadialBasisFunctions.RadialBasisOperator",href:"#RadialBasisFunctions.RadialBasisOperator"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.RadialBasisOperator")],-1)),s[154]||(s[154]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[156]||(s[156]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RadialBasisOperator</span></span></code></pre></div><p>Operator of data using a radial basis with potential monomial augmentation.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[155]||(s[155]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/operators.jl#L5-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",es,[i("summary",null,[s[157]||(s[157]=i("a",{id:"RadialBasisFunctions.RadialBasisOperator-Tuple{Any, AbstractVector}",href:"#RadialBasisFunctions.RadialBasisOperator-Tuple{Any, AbstractVector}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.RadialBasisOperator")],-1)),s[158]||(s[158]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[160]||(s[160]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ℒ, data; eval_points, basis, k, adjl, hermite, device)</span></span></code></pre></div><p>Unified constructor with keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><p><code>ℒ</code>: The operator type (e.g., <code>Laplacian()</code>, <code>Partial(1, 2)</code>)</p></li><li><p><code>data</code>: Vector of data points</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>eval_points</code>: Evaluation points (default: <code>data</code>)</p></li><li><p><code>basis</code>: RBF basis (default: <code>PHS(3; poly_deg=2)</code>)</p></li><li><p><code>k</code>: Stencil size (default: <code>autoselect_k(data, basis)</code>)</p></li><li><p><code>adjl</code>: Adjacency list (default: computed via <code>find_neighbors</code>)</p></li><li><p><code>hermite</code>: Optional NamedTuple for Hermite interpolation with fields:</p><ul><li><p><code>is_boundary::Vector{Bool}</code></p></li><li><p><code>bc::Vector{&lt;:BoundaryCondition}</code></p></li><li><p><code>normals::Vector{&lt;:AbstractVector}</code></p></li></ul></li><li><p><code>device</code>: KernelAbstractions backend for weight computation (default: auto-detected from <code>data</code> via <code>get_backend</code>)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Basic usage</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), data)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With custom basis and stencil size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), data; basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; poly_deg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With different evaluation points</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), data; eval_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eval_pts)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With Hermite boundary conditions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hermite</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(is_boundary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">is_bound, bc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boundary_conds, normals</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">normal_vecs))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With explicit device</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KernelAbstractions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">op </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Laplacian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), data; device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div>`,8)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[159]||(s[159]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/operators.jl#L39-L78",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ns,[i("summary",null,[s[161]||(s[161]=i("a",{id:"RadialBasisFunctions.RadialBasisOperator-Tuple{Any, Any}",href:"#RadialBasisFunctions.RadialBasisOperator-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.RadialBasisOperator")],-1)),s[162]||(s[162]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[164]||(s[164]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (op</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(y, x)</span></span></code></pre></div><p>Evaluate the operator at <code>x</code> in-place and store the result in <code>y</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[163]||(s[163]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/operators.jl#L174-L178",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",os,[i("summary",null,[s[165]||(s[165]=i("a",{id:"RadialBasisFunctions.RadialBasisOperator-Tuple{Any}",href:"#RadialBasisFunctions.RadialBasisOperator-Tuple{Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.RadialBasisOperator")],-1)),s[166]||(s[166]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[168]||(s[168]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (op</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RadialBasisOperator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(x)</span></span></code></pre></div><p>Evaluate the operator at <code>x</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[167]||(s[167]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/operators.jl#L164-L168",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ps,[i("summary",null,[s[169]||(s[169]=i("a",{id:"RadialBasisFunctions.Regrid",href:"#RadialBasisFunctions.Regrid"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.Regrid")],-1)),s[170]||(s[170]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[172]||(s[172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Regrid</span></span></code></pre></div><p>Operator for interpolating from one set of points to another.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[171]||(s[171]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/operators/regridding.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[518]||(s[518]=i("h2",{id:"Private",tabindex:"-1"},[l("Private "),i("a",{class:"header-anchor",href:"#Private","aria-label":'Permalink to "Private {#Private}"'},"​")],-1)),i("details",rs,[i("summary",null,[s[173]||(s[173]=i("a",{id:"RadialBasisFunctions._backward_partial_poly_1d!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T",href:"#RadialBasisFunctions._backward_partial_poly_1d!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._backward_partial_poly_1d!")],-1)),s[174]||(s[174]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[176]||(s[176]=i("p",null,"Backward pass for polynomial section in 1D.",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[175]||(s[175]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L246",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ds,[i("summary",null,[s[177]||(s[177]=i("a",{id:"RadialBasisFunctions._backward_partial_poly_2d!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T",href:"#RadialBasisFunctions._backward_partial_poly_2d!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._backward_partial_poly_2d!")],-1)),s[178]||(s[178]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[180]||(s[180]=i("p",null,"Backward pass for polynomial section in 2D.",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[179]||(s[179]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L267",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",hs,[i("summary",null,[s[181]||(s[181]=i("a",{id:"RadialBasisFunctions._backward_partial_poly_3d!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T",href:"#RadialBasisFunctions._backward_partial_poly_3d!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._backward_partial_poly_3d!")],-1)),s[182]||(s[182]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[184]||(s[184]=i("p",null,"Backward pass for polynomial section in 3D.",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[183]||(s[183]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L312",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",us,[i("summary",null,[s[185]||(s[185]=i("a",{id:"RadialBasisFunctions._backward_partial_polynomial_section!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T",href:"#RadialBasisFunctions._backward_partial_polynomial_section!-Union{Tuple{T}, Tuple{Vector{T}, AbstractVecOrMat{T}, Vararg{Int64, 4}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._backward_partial_polynomial_section!")],-1)),s[186]||(s[186]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[188]||(s[188]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_backward_partial_polynomial_section!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δeval_point, Δb, k, nmon, dim, num_ops)</span></span></code></pre></div><p>Backward pass through the polynomial section of the RHS for Partial operator.</p><p>For monomials in 2D with poly_deg=2 (1, x, y, xy, x², y²): ∂/∂x gives: 0, 1, 0, y, 2x, 0</p><p>The gradients of these w.r.t. eval_point are: ∂(0)/∂(x,y) = (0, 0) ∂(1)/∂(x,y) = (0, 0) ∂(0)/∂(x,y) = (0, 0) ∂(y)/∂(x,y) = (0, 1) -&gt; b[4] contributes to Δeval_point[2] ∂(2x)/∂(x,y) = (2, 0) -&gt; b[5] contributes 2 to Δeval_point[1] ∂(0)/∂(x,y) = (0, 0)</p><p>This is equivalent to computing the mixed second derivatives ∂²pⱼ/∂x[dim]∂x[d].</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[187]||(s[187]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L204-L221",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ks,[i("summary",null,[s[189]||(s[189]=i("a",{id:"RadialBasisFunctions._build_collocation_matrix!-Union{Tuple{Deg}, Tuple{Dim}, Tuple{Any, Any, AbstractRadialBasis, MonomialBasis{Dim, Deg}, Int64}} where {Dim, Deg}",href:"#RadialBasisFunctions._build_collocation_matrix!-Union{Tuple{Deg}, Tuple{Dim}, Tuple{Any, Any, AbstractRadialBasis, MonomialBasis{Dim, Deg}, Int64}} where {Dim, Deg}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_collocation_matrix!")],-1)),s[190]||(s[190]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[192]||(s[192]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_collocation_matrix!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A, data, basis, mon, k)</span></span></code></pre></div><p>Build RBF collocation matrix. Works for both interior stencils (AbstractVector data) and Hermite stencils (HermiteStencilData) via dispatch helpers.</p><p>Matrix structure:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">┌─────────────────┬─────────┐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Φ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xᵢ, xⱼ)      │ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xᵢ)   │  k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">k RBF </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nmon polynomial</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├─────────────────┼─────────┤</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xⱼ)ᵀ         │   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     │  nmon</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">k poly </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nmon</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nmon zero</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">└─────────────────┴─────────┘</span></span></code></pre></div><p>For Hermite stencils with Neumann/Robin conditions, basis functions are modified via <code>_rbf_entry</code> and <code>_poly_entry!</code> dispatch to maintain matrix symmetry.</p>`,5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[191]||(s[191]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L54-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",cs,[i("summary",null,[s[193]||(s[193]=i("a",{id:"RadialBasisFunctions._build_rhs!-Tuple{AbstractMatrix, Tuple, Tuple, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}",href:"#RadialBasisFunctions._build_rhs!-Tuple{AbstractMatrix, Tuple, Tuple, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_rhs!")],-1)),s[194]||(s[194]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[196]||(s[196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_rhs!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b, ℒrbf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ℒmon</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data, eval_point, basis, mon, k)</span></span></code></pre></div><p>Build RHS vector for multiple operators. Works for both interior stencils (AbstractVector) and Hermite stencils (HermiteStencilData) via dispatch helpers.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[195]||(s[195]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L140-L145",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",bs,[i("summary",null,[s[197]||(s[197]=i("a",{id:"RadialBasisFunctions._build_rhs!-Tuple{AbstractVector, Any, Any, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}",href:"#RadialBasisFunctions._build_rhs!-Tuple{AbstractVector, Any, Any, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_rhs!")],-1)),s[198]||(s[198]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[200]||(s[200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_rhs!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b, ℒrbf, ℒmon, data, eval_point, basis, mon, k)</span></span></code></pre></div><p>Build RHS vector for single operator. Works for both interior stencils (AbstractVector) and Hermite stencils (HermiteStencilData) via dispatch helpers.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[199]||(s[199]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L110-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",gs,[i("summary",null,[s[201]||(s[201]=i("a",{id:"RadialBasisFunctions._build_stencil!-Tuple{Any, Any, Any, Any, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}",href:"#RadialBasisFunctions._build_stencil!-Tuple{Any, Any, Any, Any, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_stencil!")],-1)),s[202]||(s[202]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[204]||(s[204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_stencil!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A, b, ℒrbf, ℒmon, data, eval_point, basis, mon, k)</span></span></code></pre></div><p>Assemble complete stencil: build collocation matrix, build RHS, solve for weights. Works for both interior stencils (AbstractVector) and Hermite stencils (HermiteStencilData) via dispatch helpers in <code>_build_collocation_matrix!</code> and <code>_build_rhs!</code>.</p><p>Returns: weights (first k rows of solution, size k×num_ops)</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[203]||(s[203]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L180-L188",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ys,[i("summary",null,[s[205]||(s[205]=i("a",{id:"RadialBasisFunctions._build_stencil!-Tuple{Any, Any, Any, Any, Any, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}",href:"#RadialBasisFunctions._build_stencil!-Tuple{Any, Any, Any, Any, Any, Any, Any, AbstractRadialBasis, MonomialBasis, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_stencil!")],-1)),s[206]||(s[206]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[208]||(s[208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_stencil!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(λ, A, b, ℒrbf, ℒmon, data, eval_point, basis, mon, k)</span></span></code></pre></div><p>In-place variant: writes solution into pre-allocated <code>λ</code> buffer, returns view of first k rows. Avoids allocating the solution vector and the slice on every call.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[207]||(s[207]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L205-L210",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_s,[i("summary",null,[s[209]||(s[209]=i("a",{id:"RadialBasisFunctions._build_weights-NTuple{5, Any}",href:"#RadialBasisFunctions._build_weights-NTuple{5, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_weights")],-1)),s[210]||(s[210]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[212]||(s[212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ℒ, data, eval_points, adjl, basis)</span></span></code></pre></div><p>Apply operator to basis functions and route to weight computation.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[211]||(s[211]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/api.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Es,[i("summary",null,[s[213]||(s[213]=i("a",{id:"RadialBasisFunctions._build_weights-NTuple{7, Any}",href:"#RadialBasisFunctions._build_weights-NTuple{7, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_weights")],-1)),s[214]||(s[214]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[216]||(s[216]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points, adjl, basis, ℒrbf, ℒmon, mon;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              batch_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Build weights for interior-only problems (no boundary conditions). Creates empty BoundaryData to indicate all interior points.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[215]||(s[215]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/api.jl#L41-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Cs,[i("summary",null,[s[217]||(s[217]=i("a",{id:"RadialBasisFunctions._build_weights-Tuple{Any, AbstractVector, AbstractVector, AbstractVector, AbstractRadialBasis, Vector{Bool}, Vector{<:BoundaryCondition}, Vector{<:AbstractVector}}",href:"#RadialBasisFunctions._build_weights-Tuple{Any, AbstractVector, AbstractVector, AbstractVector, AbstractRadialBasis, Vector{Bool}, Vector{<:BoundaryCondition}, Vector{<:AbstractVector}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_weights")],-1)),s[218]||(s[218]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[220]||(s[220]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ℒ, data, eval_points, adjl, basis,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              is_boundary, boundary_conditions, normals)</span></span></code></pre></div><p>Generic Hermite dispatcher for operators. Applies operator to basis and routes to Hermite weight computation.</p><p>This eliminates repetitive _build_weights methods across operator files. Note: Type constraint removed to avoid circular dependency with operators.jl</p>`,3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[219]||(s[219]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/api.jl#L113-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ms,[i("summary",null,[s[221]||(s[221]=i("a",{id:"RadialBasisFunctions._build_weights-Tuple{Any, Any, Any, Any, Any, Any, Any, Vector{Bool}, Vector{<:BoundaryCondition}, Vector{<:AbstractVector}}",href:"#RadialBasisFunctions._build_weights-Tuple{Any, Any, Any, Any, Any, Any, Any, Vector{Bool}, Vector{<:BoundaryCondition}, Vector{<:AbstractVector}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_weights")],-1)),s[222]||(s[222]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[224]||(s[224]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points, adjl, basis, ℒrbf, ℒmon, mon,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              is_boundary, boundary_conditions, normals;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              batch_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Build weights for problems with boundary conditions using Hermite interpolation. Exact allocation: Dirichlet points get single entry, others get full stencil.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[223]||(s[223]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/api.jl#L76-L83",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",fs,[i("summary",null,[s[225]||(s[225]=i("a",{id:"RadialBasisFunctions._build_weights-Tuple{Any, Any}",href:"#RadialBasisFunctions._build_weights-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._build_weights")],-1)),s[226]||(s[226]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[228]||(s[228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_build_weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ℒ, op)</span></span></code></pre></div><p>Entry point from operator construction. Extracts configuration from operator and routes to appropriate implementation.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[227]||(s[227]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/api.jl#L7-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ts,[i("summary",null,[s[229]||(s[229]=i("a",{id:"RadialBasisFunctions._construct_sparse-NTuple{6, Any}",href:"#RadialBasisFunctions._construct_sparse-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._construct_sparse")],-1)),s[230]||(s[230]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[232]||(s[232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_construct_sparse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(I, J, V, N_eval, N_data, num_ops)</span></span></code></pre></div><p>Construct sparse matrix/vector from COO arrays.</p><p><strong>Future GPU support: convert to device-sparse format here (see #88)</strong></p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[231]||(s[231]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L97-L102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Fs,[i("summary",null,[s[233]||(s[233]=i("a",{id:"RadialBasisFunctions._forward_with_cache-Union{Tuple{ℒType}, Tuple{Deg}, Tuple{Dim}, Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractRadialBasis, Any, Any, MonomialBasis{Dim, Deg}, Type{ℒType}}} where {Dim, Deg, ℒType}",href:"#RadialBasisFunctions._forward_with_cache-Union{Tuple{ℒType}, Tuple{Deg}, Tuple{Dim}, Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractRadialBasis, Any, Any, MonomialBasis{Dim, Deg}, Type{ℒType}}} where {Dim, Deg, ℒType}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._forward_with_cache")],-1)),s[234]||(s[234]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[236]||(s[236]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_forward_with_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points, adjl, basis, ℒrbf, ℒmon, mon, ℒType)</span></span></code></pre></div><p>Forward pass that builds weights while caching intermediate results for backward pass.</p><p>Returns: (W, cache) where W is the sparse weight matrix and cache contains per-stencil factorizations and solutions needed for the pullback.</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[235]||(s[235]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/forward_cache.jl#L10-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",js,[i("summary",null,[s[237]||(s[237]=i("a",{id:"RadialBasisFunctions._get_grad_funcs-Tuple{Type{<:Partial}, Any, Any}",href:"#RadialBasisFunctions._get_grad_funcs-Tuple{Type{<:Partial}, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._get_grad_funcs")],-1)),s[238]||(s[238]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[240]||(s[240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_get_grad_funcs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(OpType, basis, ℒ)</span></span></code></pre></div><p>Get gradient functions for the given operator type and basis. Returns (grad_Lφ_x, grad_Lφ_xi) tuple.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[239]||(s[239]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/ad_shared.jl#L16-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",As,[i("summary",null,[s[241]||(s[241]=i("a",{id:"RadialBasisFunctions._get_rhs_closures-Tuple{Type{<:Partial}, Any, Any}",href:"#RadialBasisFunctions._get_rhs_closures-Tuple{Type{<:Partial}, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._get_rhs_closures")],-1)),s[242]||(s[242]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[244]||(s[244]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_get_rhs_closures</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(OpType, ℒ, basis)</span></span></code></pre></div><p>Get operator-specific closures for <code>backward_stencil_with_ε!</code>. Returns <code>(poly_backward!, ∂Lφ_∂ε_fn)</code> keyword arguments.</p><ul><li><p>Partial: polynomial section backward + partial ε derivative</p></li><li><p>Laplacian: no polynomial backward + laplacian ε derivative</p></li></ul>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[243]||(s[243]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/ad_shared.jl#L31-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Bs,[i("summary",null,[s[245]||(s[245]=i("a",{id:"RadialBasisFunctions._interpolator_constructor_backward-NTuple{4, Any}",href:"#RadialBasisFunctions._interpolator_constructor_backward-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._interpolator_constructor_backward")],-1)),s[246]||(s[246]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[248]||(s[248]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_interpolator_constructor_backward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δrbf_weights, Δmon_weights, A, k)</span></span></code></pre></div><p>Backward pass for the Interpolator constructor w.r.t. <code>y</code> (the data values).</p><p>Given cotangents of <code>rbf_weights</code> and <code>monomial_weights</code>, computes the cotangent of <code>y</code> using the implicit function theorem. Since <code>w = A⁻¹ [y; 0]</code> and <code>A</code> is constant w.r.t. <code>y</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Δy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (A⁻¹ [Δrbf_weights; Δmon_weights])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">k]</span></span></code></pre></div><p>Used by both Mooncake and potentially Enzyme extensions.</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[247]||(s[247]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/interpolation_backward.jl#L48-L59",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",vs,[i("summary",null,[s[249]||(s[249]=i("a",{id:"RadialBasisFunctions._interpolator_point_gradient!-Tuple{Any, Interpolator, Any, Any}",href:"#RadialBasisFunctions._interpolator_point_gradient!-Tuple{Any, Interpolator, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._interpolator_point_gradient!")],-1)),s[250]||(s[250]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[252]||(s[252]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_interpolator_point_gradient!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δx, interp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Interpolator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, Δy)</span></span></code></pre></div><p>Accumulate the gradient of <code>interp(x) * Δy</code> into <code>Δx</code>.</p><p>RBF contribution: Σᵢ wᵢ * Δy * ∇φ(x, xᵢ) Polynomial contribution: Σⱼ wⱼ * Δy * ∇pⱼ(x)</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[251]||(s[251]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/interpolation_backward.jl#L10-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",xs,[i("summary",null,[s[253]||(s[253]=i("a",{id:"RadialBasisFunctions._num_ops-Tuple{RadialBasisFunctions.SingleOperator}",href:"#RadialBasisFunctions._num_ops-Tuple{RadialBasisFunctions.SingleOperator}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._num_ops")],-1)),s[254]||(s[254]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[256]||(s[256]=i("p",null,"Get number of operators (type-stable)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[255]||(s[255]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L238",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Rs,[i("summary",null,[s[257]||(s[257]=i("a",{id:"RadialBasisFunctions._optype-Tuple{Partial}",href:"#RadialBasisFunctions._optype-Tuple{Partial}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._optype")],-1)),s[258]||(s[258]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[260]||(s[260]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_optype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ℒ)</span></span></code></pre></div><p>Map operator instance to its abstract type for dispatch in AD rules.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[259]||(s[259]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/ad_shared.jl#L8-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ds,[i("summary",null,[s[261]||(s[261]=i("a",{id:"RadialBasisFunctions._prepare_buffer-Tuple{RadialBasisFunctions.SingleOperator, Any, Any}",href:"#RadialBasisFunctions._prepare_buffer-Tuple{RadialBasisFunctions.SingleOperator, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions._prepare_buffer")],-1)),s[262]||(s[262]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[264]||(s[264]=i("p",null,"Prepare RHS buffer with correct type (type-stable)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[263]||(s[263]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L243",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Vs,[i("summary",null,[s[265]||(s[265]=i("a",{id:"RadialBasisFunctions.allocate_sparse_arrays-Tuple{Any, Int64, Int64, Int64, Any, RadialBasisFunctions.BoundaryData}",href:"#RadialBasisFunctions.allocate_sparse_arrays-Tuple{Any, Int64, Int64, Int64, Any, RadialBasisFunctions.BoundaryData}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.allocate_sparse_arrays")],-1)),s[266]||(s[266]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[268]||(s[268]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_sparse_arrays</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TD, k, N_eval, num_ops, adjl, boundary_data)</span></span></code></pre></div><p>Allocate sparse matrix arrays for COO format sparse matrix construction. Exactly counts non-zeros: interior points get k entries, Dirichlet points get 1 entry.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[267]||(s[267]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L10-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ss,[i("summary",null,[s[269]||(s[269]=i("a",{id:"RadialBasisFunctions.autoselect_k-Union{Tuple{B}, Tuple{AbstractVector, B}} where B<:AbstractRadialBasis",href:"#RadialBasisFunctions.autoselect_k-Union{Tuple{B}, Tuple{AbstractVector, B}} where B<:AbstractRadialBasis"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.autoselect_k")],-1)),s[270]||(s[270]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[272]||(s[272]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">autoselect_k</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>See Bayona, 2017 - <a href="https://doi.org/10.1016/j.jcp.2016.12.008" target="_blank" rel="noreferrer">https://doi.org/10.1016/j.jcp.2016.12.008</a></p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[271]||(s[271]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/utils.jl#L29-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ms,[i("summary",null,[s[273]||(s[273]=i("a",{id:"RadialBasisFunctions.backward_collocation!-Union{Tuple{Deg}, Tuple{Dim}, Tuple{T}, Tuple{Array{Vector{T}, 1}, AbstractMatrix{T}, Vector{Int64}, AbstractVector, AbstractRadialBasis, MonomialBasis{Dim, Deg}, Int64}} where {T, Dim, Deg}",href:"#RadialBasisFunctions.backward_collocation!-Union{Tuple{Deg}, Tuple{Dim}, Tuple{T}, Tuple{Array{Vector{T}, 1}, AbstractMatrix{T}, Vector{Int64}, AbstractVector, AbstractRadialBasis, MonomialBasis{Dim, Deg}, Int64}} where {T, Dim, Deg}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.backward_collocation!")],-1)),s[274]||(s[274]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[276]||(s[276]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_collocation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δdata, ΔA, neighbors, data, basis, mon, k)</span></span></code></pre></div><p>Chain rule through collocation matrix construction.</p><p>The collocation matrix has structure: A[i,j] = φ(xi, xj) for i,j ≤ k (RBF block) A[i,k+j] = pⱼ(xi) for i ≤ k (polynomial block)</p><p>For RBF block (using ∇φ from existing basis_rules): Δxi += ΔA[i,j] * ∇φ(xi, xj) Δxj -= ΔA[i,j] * ∇φ(xi, xj) (by symmetry of φ(x-y))</p><p>For polynomial block: Δxi += ΔA[i,k+j] * ∇pⱼ(xi)</p><p>Note: A is symmetric, so we need to handle both triangles.</p>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[275]||(s[275]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L66-L83",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ws,[i("summary",null,[s[277]||(s[277]=i("a",{id:"RadialBasisFunctions.backward_collocation_ε!-Union{Tuple{T}, Tuple{Base.RefValue{T}, AbstractMatrix{T}, Vector{Int64}, AbstractVector, AbstractRadialBasis, Int64}} where T",href:"#RadialBasisFunctions.backward_collocation_ε!-Union{Tuple{T}, Tuple{Base.RefValue{T}, AbstractMatrix{T}, Vector{Int64}, AbstractVector, AbstractRadialBasis, Int64}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.backward_collocation_ε!")],-1)),s[278]||(s[278]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[280]||(s[280]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_collocation_ε!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δε_acc, ΔA, neighbors, data, basis, k)</span></span></code></pre></div><p>Compute gradient contribution to shape parameter ε from collocation matrix.</p><p>Uses implicit differentiation: Δε += Σᵢⱼ ΔA[i,j] * ∂A[i,j]/∂ε where A[i,j] = φ(xi, xj) for the RBF block.</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[279]||(s[279]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L364-L371",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Is,[i("summary",null,[s[281]||(s[281]=i("a",{id:"RadialBasisFunctions.backward_linear_solve!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVecOrMat{T}, AbstractVecOrMat{T}, RadialBasisFunctions.StencilForwardCache{T, M} where M<:AbstractMatrix{T}}} where T",href:"#RadialBasisFunctions.backward_linear_solve!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVecOrMat{T}, AbstractVecOrMat{T}, RadialBasisFunctions.StencilForwardCache{T, M} where M<:AbstractMatrix{T}}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.backward_linear_solve!")],-1)),s[282]||(s[282]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[284]||(s[284]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_linear_solve!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ΔA, Δb, Δw, cache)</span></span></code></pre></div><p>Compute cotangents of collocation matrix A and RHS vector b from cotangent of weights Δw.</p><p>Given: Aλ = b, w = λ[1:k] We have: Δλ = [Δw; 0] (padded with zeros for monomial part)</p><p>Using implicit function theorem: η = A⁻ᵀ Δλ ΔA = -η λᵀ Δb = η</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[283]||(s[283]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L17-L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ls,[i("summary",null,[s[285]||(s[285]=i("a",{id:"RadialBasisFunctions.backward_rhs!-Union{Tuple{F}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{T}, AbstractVecOrMat{T}, Vector{Int64}, Any, AbstractVector, AbstractRadialBasis, Int64, Any, Any}} where {T, F}",href:"#RadialBasisFunctions.backward_rhs!-Union{Tuple{F}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{T}, AbstractVecOrMat{T}, Vector{Int64}, Any, AbstractVector, AbstractRadialBasis, Int64, Any, Any}} where {T, F}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.backward_rhs!")],-1)),s[286]||(s[286]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[288]||(s[288]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_rhs!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δdata, Δeval_point, Δb, neighbors, eval_point, data, basis, k, grad_Lφ_x, grad_Lφ_xi; poly_backward</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Chain rule through RHS vector construction for any operator.</p><p>RBF section (shared by all operators): b[i] = ℒφ(eval_point, xi) → accumulate ∂/∂eval_point and ∂/∂xi</p><p>Polynomial section (Partial only — Laplacian gives constants, no gradient): b[k+j] = ℒpⱼ(eval_point) → passed as optional <code>poly_backward!</code> closure</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[287]||(s[287]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L151-L161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ps,[i("summary",null,[s[289]||(s[289]=i("a",{id:"RadialBasisFunctions.backward_rhs_ε!-Union{Tuple{F}, Tuple{T}, Tuple{Base.RefValue{T}, AbstractVecOrMat{T}, Vector{Int64}, Any, AbstractVector, Int64, F}} where {T, F}",href:"#RadialBasisFunctions.backward_rhs_ε!-Union{Tuple{F}, Tuple{T}, Tuple{Base.RefValue{T}, AbstractVecOrMat{T}, Vector{Int64}, Any, AbstractVector, Int64, F}} where {T, F}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.backward_rhs_ε!")],-1)),s[290]||(s[290]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[292]||(s[292]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_rhs_ε!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δε_acc, Δb, neighbors, eval_point, data, basis, k, ∂Lφ_∂ε_fn)</span></span></code></pre></div><p>Compute gradient contribution to shape parameter ε from RHS.</p><p><code>∂Lφ_∂ε_fn(x, xi)</code> returns ∂(ℒφ)/∂ε for the specific operator:</p><ul><li><p>Laplacian: <code>(x, xi) -&gt; ∂Laplacian_φ_∂ε(basis, x, xi)</code></p></li><li><p>Partial: <code>(x, xi) -&gt; ∂Partial_φ_∂ε(basis, dim, x, xi)</code></p></li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[291]||(s[291]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L395-L403",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Os,[i("summary",null,[s[293]||(s[293]=i("a",{id:"RadialBasisFunctions.backward_stencil_with_ε!-Union{Tuple{F2}, Tuple{F1}, Tuple{Deg}, Tuple{Dim}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{T}, Base.RefValue{T}, AbstractVecOrMat{T}, RadialBasisFunctions.StencilForwardCache{T, M} where M<:AbstractMatrix{T}, Vector{Int64}, Any, AbstractVector, AbstractRadialBasis, MonomialBasis{Dim, Deg}, Int64, Any, Any}} where {T, Dim, Deg, F1, F2}",href:"#RadialBasisFunctions.backward_stencil_with_ε!-Union{Tuple{F2}, Tuple{F1}, Tuple{Deg}, Tuple{Dim}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{T}, Base.RefValue{T}, AbstractVecOrMat{T}, RadialBasisFunctions.StencilForwardCache{T, M} where M<:AbstractMatrix{T}, Vector{Int64}, Any, AbstractVector, AbstractRadialBasis, MonomialBasis{Dim, Deg}, Int64, Any, Any}} where {T, Dim, Deg, F1, F2}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.backward_stencil_with_ε!")],-1)),s[294]||(s[294]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[296]||(s[296]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_stencil_with_ε!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δdata, Δeval_point, Δε_acc, Δw, cache, neighbors, eval_point, data, basis, mon, k, grad_Lφ_x, grad_Lφ_xi; poly_backward</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ∂Lφ_∂ε_fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Complete backward pass for a single stencil including shape parameter gradient.</p><p>Combines:</p><ol><li><p>backward_linear_solve! → compute ΔA, Δb from Δw</p></li><li><p>backward_collocation! → chain ΔA to Δdata</p></li><li><p>backward_collocation_ε! → chain ΔA to Δε</p></li><li><p>backward_rhs! → chain Δb to Δdata and Δeval_point</p></li><li><p>backward_rhs_ε! → chain Δb to Δε</p></li></ol><p>Optional closures:</p><ul><li><p><code>poly_backward!</code>: polynomial section gradient (Partial only)</p></li><li><p><code>∂Lφ_∂ε_fn</code>: shape parameter derivative function (IMQ/Gaussian only)</p></li></ul>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[295]||(s[295]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L425-L440",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ns,[i("summary",null,[s[297]||(s[297]=i("a",{id:"RadialBasisFunctions.build_weights_kernel-Tuple{Any, Any, Any, Any, Any, Any, Any, RadialBasisFunctions.BoundaryData}",href:"#RadialBasisFunctions.build_weights_kernel-Tuple{Any, Any, Any, Any, Any, Any, Any, RadialBasisFunctions.BoundaryData}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.build_weights_kernel")],-1)),s[298]||(s[298]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[300]||(s[300]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_weights_kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, eval_points, adjl, basis, ℒrbf, ℒmon, mon,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    boundary_data; batch_size, device)</span></span></code></pre></div><p>Main orchestrator for weight computation. Currently CPU-only. GPU stencil solve is not yet supported — see GitHub issue #88.</p>`,2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[299]||(s[299]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L119-L125",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Js,[i("summary",null,[s[301]||(s[301]=i("a",{id:"RadialBasisFunctions.build_weights_pullback_loop!-Union{Tuple{OpType}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Vector{T}, 1}, Base.RefValue{T}, Any, RadialBasisFunctions.WeightsBuildForwardCache, AbstractVector, AbstractVector, AbstractVector, AbstractRadialBasis, MonomialBasis, Any, Type{OpType}, Any, Any}} where {T, OpType}",href:"#RadialBasisFunctions.build_weights_pullback_loop!-Union{Tuple{OpType}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Vector{T}, 1}, Base.RefValue{T}, Any, RadialBasisFunctions.WeightsBuildForwardCache, AbstractVector, AbstractVector, AbstractVector, AbstractRadialBasis, MonomialBasis, Any, Type{OpType}, Any, Any}} where {T, OpType}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.build_weights_pullback_loop!")],-1)),s[302]||(s[302]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[304]||(s[304]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_weights_pullback_loop!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δdata, Δeval, Δε_acc, ΔW_extractor, cache, adjl,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    eval_points, data, basis, mon, ℒ, OpType, grad_Lφ_x, grad_Lφ_xi)</span></span></code></pre></div><p>Shared stencil iteration loop for _build_weights pullback across all AD backends.</p><p><code>ΔW_extractor(eval_idx, neighbors, k)</code> is a callable that returns the stencil cotangent matrix <code>Δw</code> given the eval index, neighbor list, and stencil size. This abstracts over the different ways each AD framework stores cotangents (dense matrix, nzval vector, etc.).</p>`,3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[303]||(s[303]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/ad_shared.jl#L53-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Hs,[i("summary",null,[s[305]||(s[305]=i("a",{id:"RadialBasisFunctions.calculate_batch_range-Tuple{Int64, Int64, Int64}",href:"#RadialBasisFunctions.calculate_batch_range-Tuple{Int64, Int64, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.calculate_batch_range")],-1)),s[306]||(s[306]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[308]||(s[308]=i("p",null,"Calculate batch index range for kernel execution",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[307]||(s[307]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Us,[i("summary",null,[s[309]||(s[309]=i("a",{id:"RadialBasisFunctions.compute_hermite_poly_entry!-Tuple{AbstractVector, Int64, HermiteStencilData, MonomialBasis}",href:"#RadialBasisFunctions.compute_hermite_poly_entry!-Tuple{AbstractVector, Int64, HermiteStencilData, MonomialBasis}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.compute_hermite_poly_entry!")],-1)),s[310]||(s[310]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[312]||(s[312]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_hermite_poly_entry!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, i, data, mon)</span></span></code></pre></div><p>Compute polynomial entries for Hermite interpolation. Dispatches based on boundary point type for type stability.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[311]||(s[311]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L349-L354",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Gs,[i("summary",null,[s[313]||(s[313]=i("a",{id:"RadialBasisFunctions.compute_hermite_rbf_entry-Tuple{Int64, Int64, HermiteStencilData, RadialBasisFunctions.BasisOperators}",href:"#RadialBasisFunctions.compute_hermite_rbf_entry-Tuple{Int64, Int64, HermiteStencilData, RadialBasisFunctions.BasisOperators}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.compute_hermite_rbf_entry")],-1)),s[314]||(s[314]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[316]||(s[316]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_hermite_rbf_entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, j, data, ops)</span></span></code></pre></div><p>Compute single RBF matrix entry with Hermite boundary modifications. Dispatches based on point types (Interior/Dirichlet/NeumannRobin).</p><p>Uses <code>BasisOperators</code> for efficient evaluation (avoids functor construction in hot loop).</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[315]||(s[315]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L247-L254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",zs,[i("summary",null,[s[317]||(s[317]=i("a",{id:"RadialBasisFunctions.construct_global_to_boundary-Tuple{Vector{Bool}}",href:"#RadialBasisFunctions.construct_global_to_boundary-Tuple{Vector{Bool}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.construct_global_to_boundary")],-1)),s[318]||(s[318]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[320]||(s[320]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">construct_global_to_boundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(is_boundary)</span></span></code></pre></div><p>Construct mapping from global indices to boundary-only indices. For boundary points: global_to_boundary[i] = boundary array index For interior points: global_to_boundary[i] = 0 (sentinel)</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[319]||(s[319]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L69-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ws,[i("summary",null,[s[321]||(s[321]=i("a",{id:"RadialBasisFunctions.count_nonzeros-Tuple{Any, Vector{Bool}, Vector{<:BoundaryCondition}}",href:"#RadialBasisFunctions.count_nonzeros-Tuple{Any, Vector{Bool}, Vector{<:BoundaryCondition}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.count_nonzeros")],-1)),s[322]||(s[322]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[324]||(s[324]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count_nonzeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(adjl, is_boundary, boundary_conditions)</span></span></code></pre></div><p>Count exact number of non-zero entries for optimized allocation. Returns (total_nnz, row_offsets) where row_offsets[i] is the starting position for row i.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[323]||(s[323]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L31-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Zs,[i("summary",null,[s[325]||(s[325]=i("a",{id:"RadialBasisFunctions.extract_stencil_cotangent-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Vector{Int64}, Int64, Int64}} where T",href:"#RadialBasisFunctions.extract_stencil_cotangent-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Vector{Int64}, Int64, Int64}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.extract_stencil_cotangent")],-1)),s[326]||(s[326]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[328]||(s[328]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extract_stencil_cotangent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ΔW, eval_idx, neighbors, k, num_ops)</span></span></code></pre></div><p>Extract cotangent values for a single stencil from a dense/sparse matrix cotangent. Used by the Enzyme extension.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[327]||(s[327]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L481-L486",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Qs,[i("summary",null,[s[329]||(s[329]=i("a",{id:"RadialBasisFunctions.extract_stencil_cotangent_from_nzval-Union{Tuple{T}, Tuple{Vector{T}, SparseArrays.SparseMatrixCSC, Int64, Vector{Int64}, Int64}} where T",href:"#RadialBasisFunctions.extract_stencil_cotangent_from_nzval-Union{Tuple{T}, Tuple{Vector{T}, SparseArrays.SparseMatrixCSC, Int64, Vector{Int64}, Int64}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.extract_stencil_cotangent_from_nzval")],-1)),s[330]||(s[330]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[332]||(s[332]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extract_stencil_cotangent_from_nzval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ΔW_nzval, W, eval_idx, neighbors, k)</span></span></code></pre></div><p>Extract cotangent values for a single stencil from sparse matrix nzval gradient. Used by Mooncake extension where gradients are stored in fdata.nzval.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[331]||(s[331]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward.jl#L497-L502",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",qs,[i("summary",null,[s[333]||(s[333]=i("a",{id:"RadialBasisFunctions.fill_dirichlet_entry!-Tuple{Any, Any, Any, Int64, Int64, Int64}",href:"#RadialBasisFunctions.fill_dirichlet_entry!-Tuple{Any, Any, Any, Int64, Int64, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.fill_dirichlet_entry!")],-1)),s[334]||(s[334]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[336]||(s[336]=i("p",null,"Fill Dirichlet identity row for optimized allocation",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[335]||(s[335]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ks,[i("summary",null,[s[337]||(s[337]=i("a",{id:"RadialBasisFunctions.fill_entries!-Tuple{Any, Any, Any, Any, Int64, Any, Int64, Int64, Int64}",href:"#RadialBasisFunctions.fill_entries!-Tuple{Any, Any, Any, Any, Int64, Any, Int64, Int64, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.fill_entries!")],-1)),s[338]||(s[338]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[340]||(s[340]=i("p",null,"Fill sparse matrix entries using indexed storage (row_offsets)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[339]||(s[339]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L275",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$s,[i("summary",null,[s[341]||(s[341]=i("a",{id:"RadialBasisFunctions.grad_applied_laplacian_wrt_x-Tuple{PHS1}",href:"#RadialBasisFunctions.grad_applied_laplacian_wrt_x-Tuple{PHS1}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_applied_laplacian_wrt_x")],-1)),s[342]||(s[342]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[344]||(s[344]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_applied_laplacian_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis)</span></span></code></pre></div><p>Get gradient of applied Laplacian operator w.r.t. evaluation point.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[343]||(s[343]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L429-L433",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Xs,[i("summary",null,[s[345]||(s[345]=i("a",{id:"RadialBasisFunctions.grad_applied_laplacian_wrt_xi-Tuple{Any}",href:"#RadialBasisFunctions.grad_applied_laplacian_wrt_xi-Tuple{Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_applied_laplacian_wrt_xi")],-1)),s[346]||(s[346]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[348]||(s[348]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_applied_laplacian_wrt_xi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis)</span></span></code></pre></div><p>Get gradient of applied Laplacian operator w.r.t. data point. By symmetry, always the negation of the <code>_wrt_x</code> version.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[347]||(s[347]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L441-L446",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ys,[i("summary",null,[s[349]||(s[349]=i("a",{id:"RadialBasisFunctions.grad_applied_partial_wrt_x-Tuple{PHS1, Int64}",href:"#RadialBasisFunctions.grad_applied_partial_wrt_x-Tuple{PHS1, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_applied_partial_wrt_x")],-1)),s[350]||(s[350]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[352]||(s[352]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_applied_partial_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis, dim)</span></span></code></pre></div><p>Get gradient of applied partial derivative operator w.r.t. evaluation point.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[351]||(s[351]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L409-L413",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",si,[i("summary",null,[s[353]||(s[353]=i("a",{id:"RadialBasisFunctions.grad_applied_partial_wrt_xi-Tuple{Any, Int64}",href:"#RadialBasisFunctions.grad_applied_partial_wrt_xi-Tuple{Any, Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_applied_partial_wrt_xi")],-1)),s[354]||(s[354]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[356]||(s[356]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_applied_partial_wrt_xi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis, dim)</span></span></code></pre></div><p>Get gradient of applied partial derivative operator w.r.t. data point. By symmetry, always the negation of the <code>_wrt_x</code> version.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[355]||(s[355]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L421-L426",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ii,[i("summary",null,[s[357]||(s[357]=i("a",{id:"RadialBasisFunctions.grad_laplacian_gaussian_wrt_x-Tuple{T} where T",href:"#RadialBasisFunctions.grad_laplacian_gaussian_wrt_x-Tuple{T} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_laplacian_gaussian_wrt_x")],-1)),s[358]||(s[358]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[360]||(s[360]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_laplacian_gaussian_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ε)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∇²φ] for Gaussian.</p><p>Mathematical derivation: ∇²φ = (4ε⁴r² - 2ε²D) * φ</p><p>∂(∇²φ)/∂x[j] = φ * δ_j * 4ε⁴ * [2 + D - 2ε²r²]</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[359]||(s[359]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L381-L390",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ai,[i("summary",null,[s[361]||(s[361]=i("a",{id:"RadialBasisFunctions.grad_laplacian_imq_wrt_x-Tuple{T} where T",href:"#RadialBasisFunctions.grad_laplacian_imq_wrt_x-Tuple{T} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_laplacian_imq_wrt_x")],-1)),s[362]||(s[362]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[364]||(s[364]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_laplacian_imq_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ε)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∇²φ] for IMQ.</p><p>Mathematical derivation: ∇²φ = sum_i [∂²φ/∂x[i]²] = 3ε⁴r²/s^(5/2) - D*ε²/s^(3/2)</p><p>∂(∇²φ)/∂x[j] = δ_j * [3(D+2)ε⁴/s^(5/2) - 15ε⁶r²/s^(7/2)]</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[363]||(s[363]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L308-L317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ti,[i("summary",null,[s[365]||(s[365]=i("a",{id:"RadialBasisFunctions.grad_laplacian_phs1_wrt_x-Tuple{}",href:"#RadialBasisFunctions.grad_laplacian_phs1_wrt_x-Tuple{}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_laplacian_phs1_wrt_x")],-1)),s[366]||(s[366]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[368]||(s[368]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_laplacian_phs1_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∇²φ] for PHS1.</p><p>Mathematical derivation: ∇²φ = 2/r ∂/∂x[j] [2/r] = -2 * δ_j / r³</p><p>Note: At r=0, we return 0 to avoid singularity.</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[367]||(s[367]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L124-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",li,[i("summary",null,[s[369]||(s[369]=i("a",{id:"RadialBasisFunctions.grad_laplacian_phs3_wrt_x-Tuple{}",href:"#RadialBasisFunctions.grad_laplacian_phs3_wrt_x-Tuple{}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_laplacian_phs3_wrt_x")],-1)),s[370]||(s[370]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[372]||(s[372]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_laplacian_phs3_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∇²φ] for PHS3.</p><p>Mathematical derivation: ∇²φ = 12r ∂/∂x[j] [12r] = 12 * δ_j / r</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[371]||(s[371]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L62-L70",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ei,[i("summary",null,[s[373]||(s[373]=i("a",{id:"RadialBasisFunctions.grad_laplacian_phs5_wrt_x-Tuple{}",href:"#RadialBasisFunctions.grad_laplacian_phs5_wrt_x-Tuple{}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_laplacian_phs5_wrt_x")],-1)),s[374]||(s[374]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[376]||(s[376]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_laplacian_phs5_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∇²φ] for PHS5.</p><p>Mathematical derivation: ∇²φ = 30r³ ∂/∂x[j] [30r³] = 30 * 3r² * δ_j / r = 90 * r * δ_j</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[375]||(s[375]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L185-L193",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ni,[i("summary",null,[s[377]||(s[377]=i("a",{id:"RadialBasisFunctions.grad_laplacian_phs7_wrt_x-Tuple{}",href:"#RadialBasisFunctions.grad_laplacian_phs7_wrt_x-Tuple{}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_laplacian_phs7_wrt_x")],-1)),s[378]||(s[378]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[380]||(s[380]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_laplacian_phs7_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∇²φ] for PHS7.</p><p>Mathematical derivation: ∇²φ = 56r⁵ ∂/∂x[j] [56r⁵] = 56 * 5r⁴ * δ_j / r = 280 * r³ * δ_j</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[379]||(s[379]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L239-L247",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",oi,[i("summary",null,[s[381]||(s[381]=i("a",{id:"RadialBasisFunctions.grad_partial_gaussian_wrt_x-Union{Tuple{T}, Tuple{T, Int64}} where T",href:"#RadialBasisFunctions.grad_partial_gaussian_wrt_x-Union{Tuple{T}, Tuple{T, Int64}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_partial_gaussian_wrt_x")],-1)),s[382]||(s[382]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[384]||(s[384]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_partial_gaussian_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ε, dim)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∂φ/∂x[dim]] for Gaussian.</p><p>Mathematical derivation: φ = exp(-ε²r²) ∂φ/∂x[dim] = -2ε² * δ_d * φ</p><p>∂²φ/∂x[j]∂x[dim] = φ * [-2ε² * δ_{j,dim} + 4ε⁴ * δ_d * δ_j]</p><p>For j == dim: φ * (4ε⁴ * δ_d² - 2ε²) For j != dim: φ * 4ε⁴ * δ_d * δ_j</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[383]||(s[383]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L340-L353",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",pi,[i("summary",null,[s[385]||(s[385]=i("a",{id:"RadialBasisFunctions.grad_partial_imq_wrt_x-Union{Tuple{T}, Tuple{T, Int64}} where T",href:"#RadialBasisFunctions.grad_partial_imq_wrt_x-Union{Tuple{T}, Tuple{T, Int64}} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_partial_imq_wrt_x")],-1)),s[386]||(s[386]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[388]||(s[388]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_partial_imq_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ε, dim)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∂φ/∂x[dim]] for IMQ.</p><p>Mathematical derivation: Let s = ε²r² + 1, δ_d = x[dim] - xi[dim] ∂φ/∂x[dim] = -ε² * δ_d / s^(3/2)</p><p>∂²φ/∂x[j]∂x[dim] = -ε² * [δ_{j,dim} / s^(3/2) - δ_d * (3/2) * s^(-5/2) * 2ε² * δ_j] = -ε² * δ_{j,dim} / s^(3/2) + 3ε⁴ * δ_d * δ_j / s^(5/2)</p><p>For j == dim: -ε² / s^(3/2) + 3ε⁴ * δ_d² / s^(5/2) For j != dim: 3ε⁴ * δ_d * δ_j / s^(5/2)</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[387]||(s[387]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L264-L278",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ri,[i("summary",null,[s[389]||(s[389]=i("a",{id:"RadialBasisFunctions.grad_partial_phs1_wrt_x-Tuple{Int64}",href:"#RadialBasisFunctions.grad_partial_phs1_wrt_x-Tuple{Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_partial_phs1_wrt_x")],-1)),s[390]||(s[390]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[392]||(s[392]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_partial_phs1_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dim)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∂φ/∂x[dim]] for PHS1.</p><p>Mathematical derivation: ∂φ/∂x[dim] = δ_d / r</p><p>∂²φ/∂x[j]∂x[dim] = (δ_{j,dim} * r - δ_d * δ_j / r) / r² = δ_{j,dim} / r - δ_d * δ_j / r³</p><p>Note: At r=0, the derivative is singular but we return 0 since the RBF value itself is 0 at r=0, so this term doesn&#39;t contribute to the gradient.</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[391]||(s[391]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L86-L99",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",di,[i("summary",null,[s[393]||(s[393]=i("a",{id:"RadialBasisFunctions.grad_partial_phs3_wrt_x-Tuple{Int64}",href:"#RadialBasisFunctions.grad_partial_phs3_wrt_x-Tuple{Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_partial_phs3_wrt_x")],-1)),s[394]||(s[394]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[396]||(s[396]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_partial_phs3_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dim)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∂φ/∂x[dim]] for PHS3.</p><p>Mathematical derivation: ∂φ/∂x[dim] = 3 * δ_d * r where δ_d = x[dim] - xi[dim], r = ||x - xi||</p><p>∂²φ/∂x[j]∂x[dim] = 3 * (δ_{j,dim} * r + δ_d * δ_j / r)</p><p>For j == dim: 3 * (r + δ_d² / r) For j != dim: 3 * δ_d * δ_j / r</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[395]||(s[395]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L25-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",hi,[i("summary",null,[s[397]||(s[397]=i("a",{id:"RadialBasisFunctions.grad_partial_phs5_wrt_x-Tuple{Int64}",href:"#RadialBasisFunctions.grad_partial_phs5_wrt_x-Tuple{Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_partial_phs5_wrt_x")],-1)),s[398]||(s[398]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[400]||(s[400]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_partial_phs5_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dim)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∂φ/∂x[dim]] for PHS5.</p><p>Mathematical derivation: ∂φ/∂x[dim] = 5 * δ_d * r³</p><p>∂²φ/∂x[j]∂x[dim] = 5 * (δ_{j,dim} * r³ + δ_d * 3r * δ_j) = 5 * (δ_{j,dim} * r³ + 3 * δ_d * δ_j * r)</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[399]||(s[399]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L154-L164",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ui,[i("summary",null,[s[401]||(s[401]=i("a",{id:"RadialBasisFunctions.grad_partial_phs7_wrt_x-Tuple{Int64}",href:"#RadialBasisFunctions.grad_partial_phs7_wrt_x-Tuple{Int64}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.grad_partial_phs7_wrt_x")],-1)),s[402]||(s[402]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[404]||(s[404]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grad_partial_phs7_wrt_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dim)</span></span></code></pre></div><p>Returns a function computing ∂/∂x[j] of [∂φ/∂x[dim]] for PHS7.</p><p>Mathematical derivation: ∂φ/∂x[dim] = 7 * δ_d * r⁵</p><p>∂²φ/∂x[j]∂x[dim] = 7 * (δ_{j,dim} * r⁵ + δ_d * 5r³ * δ_j)</p>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[403]||(s[403]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L208-L217",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ki,[i("summary",null,[s[405]||(s[405]=i("a",{id:"RadialBasisFunctions.hermite_mono_rhs!-Tuple{AbstractVector, Any, MonomialBasis, Any, Bool, BoundaryCondition, Any, AbstractVector}",href:"#RadialBasisFunctions.hermite_mono_rhs!-Tuple{AbstractVector, Any, MonomialBasis, Any, Bool, BoundaryCondition, Any, AbstractVector}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.hermite_mono_rhs!")],-1)),s[406]||(s[406]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[408]||(s[408]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hermite_mono_rhs!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bmono, ℒmon, mon, eval_point, is_bound, bc, normal, workspace)</span></span></code></pre></div><p>Apply boundary conditions to monomial operator evaluation. Dispatches based on boundary point type for type stability.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[407]||(s[407]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L426-L431",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ci,[i("summary",null,[s[409]||(s[409]=i("a",{id:"RadialBasisFunctions.hermite_rbf_rhs-Tuple{Any, Any, Any, Bool, BoundaryCondition, Any}",href:"#RadialBasisFunctions.hermite_rbf_rhs-Tuple{Any, Any, Any, Bool, BoundaryCondition, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.hermite_rbf_rhs")],-1)),s[410]||(s[410]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[412]||(s[412]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hermite_rbf_rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ℒrbf, eval_point, data_point, is_bound, bc, normal)</span></span></code></pre></div><p>Apply boundary conditions to RBF operator evaluation.</p><ul><li><p>Interior/Dirichlet: standard evaluation ℒΦ(x_eval, x_data)</p></li><li><p>Neumann/Robin: α_ℒΦ + β_ℒ(∂ₙΦ)</p></li></ul>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[411]||(s[411]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/assembly.jl#L407-L413",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",bi,[i("summary",null,[s[413]||(s[413]=i("a",{id:"RadialBasisFunctions.launch_kernel!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, RadialBasisFunctions.BoundaryData, Vararg{Any, 8}}",href:"#RadialBasisFunctions.launch_kernel!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, RadialBasisFunctions.BoundaryData, Vararg{Any, 8}}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.launch_kernel!")],-1)),s[414]||(s[414]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[416]||(s[416]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">launch_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Launch parallel CPU kernel for weight computation. Handles Dirichlet/Interior/Hermite stencil classification via dispatch.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[415]||(s[415]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/execution.jl#L176-L181",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",gi,[i("summary",null,[s[417]||(s[417]=i("a",{id:"RadialBasisFunctions.negate_grad-Tuple{Any}",href:"#RadialBasisFunctions.negate_grad-Tuple{Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.negate_grad")],-1)),s[418]||(s[418]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[420]||(s[420]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">negate_grad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grad_fn)</span></span></code></pre></div><p>Given a gradient function <code>grad_fn(x, xi)</code>, returns <code>(x, xi) -&gt; -grad_fn(x, xi)</code>. All <code>_wrt_xi</code> functions are the negation of their <code>_wrt_x</code> counterparts by symmetry.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[419]||(s[419]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/operator_second_derivatives.jl#L12-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",yi,[i("summary",null,[s[421]||(s[421]=i("a",{id:"RadialBasisFunctions.operator_arity-Tuple{T} where T",href:"#RadialBasisFunctions.operator_arity-Tuple{T} where T"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.operator_arity")],-1)),s[422]||(s[422]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[424]||(s[424]=i("p",null,"Extract operator arity at compile time",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[423]||(s[423]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L233",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_i,[i("summary",null,[s[425]||(s[425]=i("a",{id:"RadialBasisFunctions.point_type-Tuple{Bool, BoundaryCondition}",href:"#RadialBasisFunctions.point_type-Tuple{Bool, BoundaryCondition}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.point_type")],-1)),s[426]||(s[426]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[428]||(s[428]=i("p",null,"Determine boundary type of a single point",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[427]||(s[427]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L215",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ei,[i("summary",null,[s[429]||(s[429]=i("a",{id:"RadialBasisFunctions.∂Laplacian_φ_∂ε-Tuple{Gaussian, Any, Any}",href:"#RadialBasisFunctions.∂Laplacian_φ_∂ε-Tuple{Gaussian, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂Laplacian_φ_∂ε")],-1)),s[430]||(s[430]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[432]||(s[432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂Laplacian_φ_∂ε</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gaussian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, xi)</span></span></code></pre></div><p>Derivative of Laplacian of Gaussian basis w.r.t. shape parameter ε.</p><p>∇²φ = (-2ε²D + 4ε⁴r²) exp(-ε²r²), where D = dimension ∂(∇²φ)/∂ε = exp(-ε²r²) [-4εD + 16ε³r² + 4ε³r²D - 8ε⁵r⁴]</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[431]||(s[431]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/shape_parameter_derivatives.jl#L33-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ci,[i("summary",null,[s[433]||(s[433]=i("a",{id:"RadialBasisFunctions.∂Laplacian_φ_∂ε-Tuple{IMQ, Any, Any}",href:"#RadialBasisFunctions.∂Laplacian_φ_∂ε-Tuple{IMQ, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂Laplacian_φ_∂ε")],-1)),s[434]||(s[434]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[436]||(s[436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂Laplacian_φ_∂ε</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IMQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, xi)</span></span></code></pre></div><p>Derivative of Laplacian of IMQ basis w.r.t. shape parameter ε.</p><p>Let s = ε²r² + 1, D = dimension ∇²φ = -ε²D/s^(3/2) + 3ε⁴r²/s^(5/2) ∂(∇²φ)/∂ε = ∂/∂ε[-ε²D s^(-3/2) + 3ε⁴r² s^(-5/2)]</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[435]||(s[435]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/shape_parameter_derivatives.jl#L88-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",mi,[i("summary",null,[s[437]||(s[437]=i("a",{id:"RadialBasisFunctions.∂Partial_φ_∂ε-Tuple{Gaussian, Int64, Any, Any}",href:"#RadialBasisFunctions.∂Partial_φ_∂ε-Tuple{Gaussian, Int64, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂Partial_φ_∂ε")],-1)),s[438]||(s[438]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[440]||(s[440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂Partial_φ_∂ε</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gaussian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, xi)</span></span></code></pre></div><p>Derivative of first partial derivative of Gaussian basis w.r.t. shape parameter ε.</p><p>∂φ/∂x_dim = -2ε²(x_dim - xi_dim) exp(-ε²r²) ∂/∂ε[∂φ/∂x_dim] = 4ε(x_dim - xi_dim)(ε²r² - 1) exp(-ε²r²)</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[439]||(s[439]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/shape_parameter_derivatives.jl#L52-L59",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",fi,[i("summary",null,[s[441]||(s[441]=i("a",{id:"RadialBasisFunctions.∂Partial_φ_∂ε-Tuple{IMQ, Int64, Any, Any}",href:"#RadialBasisFunctions.∂Partial_φ_∂ε-Tuple{IMQ, Int64, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂Partial_φ_∂ε")],-1)),s[442]||(s[442]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[444]||(s[444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂Partial_φ_∂ε</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IMQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, xi)</span></span></code></pre></div><p>Derivative of first partial derivative of IMQ basis w.r.t. shape parameter ε.</p><p>∂φ/∂x_dim = ε²(xi_dim - x_dim) s^(-3/2) ∂/∂ε[∂φ/∂x_dim] = 2ε(xi_dim - x_dim) s^(-3/2) + ε²(xi_dim - x_dim)(-3/2)s^(-5/2) · 2εr² = (xi_dim - x_dim)[2ε s^(-3/2) - 3ε³r² s^(-5/2)]</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[443]||(s[443]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/shape_parameter_derivatives.jl#L119-L127",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ti,[i("summary",null,[s[445]||(s[445]=i("a",{id:"RadialBasisFunctions.∂φ_∂ε-Tuple{Gaussian, Any, Any}",href:"#RadialBasisFunctions.∂φ_∂ε-Tuple{Gaussian, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂φ_∂ε")],-1)),s[446]||(s[446]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[448]||(s[448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂φ_∂ε</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gaussian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, xi)</span></span></code></pre></div><p>Derivative of Gaussian basis function w.r.t. shape parameter ε.</p><p>φ(r) = exp(-ε²r²) ∂φ/∂ε = -2εr² exp(-ε²r²)</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[447]||(s[447]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/shape_parameter_derivatives.jl#L19-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Fi,[i("summary",null,[s[449]||(s[449]=i("a",{id:"RadialBasisFunctions.∂φ_∂ε-Tuple{IMQ, Any, Any}",href:"#RadialBasisFunctions.∂φ_∂ε-Tuple{IMQ, Any, Any}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂φ_∂ε")],-1)),s[450]||(s[450]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[452]||(s[452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂φ_∂ε</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IMQ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, xi)</span></span></code></pre></div><p>Derivative of IMQ basis function w.r.t. shape parameter ε.</p><p>φ(r) = (ε²r² + 1)^(-1/2) ∂φ/∂ε = -εr² (ε²r² + 1)^(-3/2)</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[451]||(s[451]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/shape_parameter_derivatives.jl#L73-L80",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ji,[i("summary",null,[s[453]||(s[453]=i("a",{id:"RadialBasisFunctions.AbstractBasis",href:"#RadialBasisFunctions.AbstractBasis"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.AbstractBasis")],-1)),s[454]||(s[454]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[456]||(s[456]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractBasis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>',1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[455]||(s[455]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ai,[i("summary",null,[s[457]||(s[457]=i("a",{id:"RadialBasisFunctions.BasisOperators",href:"#RadialBasisFunctions.BasisOperators"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.BasisOperators")],-1)),s[458]||(s[458]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[460]||(s[460]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BasisOperators{B,G,Hess}</span></span></code></pre></div><p>Bundle of pre-constructed basis operators for efficient evaluation in hot loops. Avoids repeated functor construction inside <code>hermite_rbf_dispatch</code>.</p><p>Fields:</p><ul><li><p><code>φ</code>: The basis function itself</p></li><li><p><code>∇φ</code>: Gradient operator (pre-constructed ∇(basis))</p></li><li><p><code>Hφ</code>: Hessian operator (pre-constructed H(basis))</p></li></ul><p>Usage:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ops </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BasisOperators</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># In hot loop:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">φ_val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">φ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, xᵢ)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">grad </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∇φ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, xᵢ)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Returns vector</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hess </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ops</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Hφ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, xᵢ)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Returns matrix</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dφ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n, grad)         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Directional derivative</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D²φ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ni, hess </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nj)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Second directional derivative</span></span></code></pre></div>`,6)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[459]||(s[459]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L252-L273",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Bi,[i("summary",null,[s[461]||(s[461]=i("a",{id:"RadialBasisFunctions.BasisOperators-Tuple{AbstractRadialBasis}",href:"#RadialBasisFunctions.BasisOperators-Tuple{AbstractRadialBasis}"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.BasisOperators")],-1)),s[462]||(s[462]=l()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[464]||(s[464]=i("p",null,"Construct BasisOperators from a basis function.",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[463]||(s[463]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L280",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",vi,[i("summary",null,[s[465]||(s[465]=i("a",{id:"RadialBasisFunctions.BoundaryData",href:"#RadialBasisFunctions.BoundaryData"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.BoundaryData")],-1)),s[466]||(s[466]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[468]||(s[468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BoundaryData{T}</span></span></code></pre></div><p>Wrapper for global boundary information (replaces fragile tuples).</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[467]||(s[467]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L145-L149",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",xi,[i("summary",null,[s[469]||(s[469]=i("a",{id:"RadialBasisFunctions.BoundaryPointType",href:"#RadialBasisFunctions.BoundaryPointType"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.BoundaryPointType")],-1)),s[470]||(s[470]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[472]||(s[472]=i("p",null,"Trait types for individual point boundary classification",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[471]||(s[471]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ri,[i("summary",null,[s[473]||(s[473]=i("a",{id:"RadialBasisFunctions.D",href:"#RadialBasisFunctions.D"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.D")],-1)),s[474]||(s[474]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[476]||(s[476]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,V}</span></span></code></pre></div><p>Directional derivative operator functor. Construct with <code>D(basis, v)</code>. Computes the derivative of the basis function in direction <code>v</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[475]||(s[475]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L52-L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Di,[i("summary",null,[s[477]||(s[477]=i("a",{id:"RadialBasisFunctions.D²",href:"#RadialBasisFunctions.D²"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.D²")],-1)),s[478]||(s[478]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[480]||(s[480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D²{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,V1,V2}</span></span></code></pre></div><p>Directional second derivative operator functor. Construct with <code>D²(basis, v1, v2)</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[479]||(s[479]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L63-L67",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Vi,[i("summary",null,[s[481]||(s[481]=i("a",{id:"RadialBasisFunctions.H",href:"#RadialBasisFunctions.H"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.H")],-1)),s[482]||(s[482]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[484]||(s[484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">H{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Hessian operator functor. Construct with <code>H(basis)</code>. Returns the Hessian matrix of the basis function.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[483]||(s[483]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L74-L79",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Si,[i("summary",null,[s[485]||(s[485]=i("a",{id:"RadialBasisFunctions.OperatorArity",href:"#RadialBasisFunctions.OperatorArity"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.OperatorArity")],-1)),s[486]||(s[486]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[488]||(s[488]=i("p",null,"Operator arity traits for compile-time dispatch",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[487]||(s[487]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L228",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Mi,[i("summary",null,[s[489]||(s[489]=i("a",{id:"RadialBasisFunctions.StencilForwardCache",href:"#RadialBasisFunctions.StencilForwardCache"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.StencilForwardCache")],-1)),s[490]||(s[490]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[492]||(s[492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">StencilForwardCache{T}</span></span></code></pre></div><p>Per-stencil storage from forward pass needed for backward pass.</p><ul><li><p><code>lambda</code>: Full solution vector (k+nmon) × num_ops from solving Aλ = b</p></li><li><p><code>A_mat</code>: The symmetric collocation matrix (stored for backprop)</p></li><li><p><code>k</code>: Number of RBF neighbors in stencil</p></li><li><p><code>nmon</code>: Number of monomial basis functions</p></li></ul>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[491]||(s[491]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward_cache.jl#L14-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",wi,[i("summary",null,[s[493]||(s[493]=i("a",{id:"RadialBasisFunctions.StencilType",href:"#RadialBasisFunctions.StencilType"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.StencilType")],-1)),s[494]||(s[494]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[496]||(s[496]=i("p",null,"Trait types for stencil classification",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[495]||(s[495]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/types.jl#L160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ii,[i("summary",null,[s[497]||(s[497]=i("a",{id:"RadialBasisFunctions.WeightsBuildForwardCache",href:"#RadialBasisFunctions.WeightsBuildForwardCache"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.WeightsBuildForwardCache")],-1)),s[498]||(s[498]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[500]||(s[500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WeightsBuildForwardCache{T}</span></span></code></pre></div><p>Global cache storing all stencil results and references to inputs.</p><ul><li><p><code>stencil_caches</code>: Vector of StencilForwardCache, one per evaluation point</p></li><li><p><code>k</code>: Stencil size (number of neighbors)</p></li><li><p><code>nmon</code>: Number of monomial basis functions</p></li><li><p><code>num_ops</code>: Number of operators (1 for scalar, D for gradient)</p></li></ul>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[499]||(s[499]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/solve/backward_cache.jl#L31-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Li,[i("summary",null,[s[501]||(s[501]=i("a",{id:"RadialBasisFunctions.∂",href:"#RadialBasisFunctions.∂"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂")],-1)),s[502]||(s[502]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[504]||(s[504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Partial derivative operator functor. Construct with <code>∂(basis, dim)</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[503]||(s[503]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L14-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Pi,[i("summary",null,[s[505]||(s[505]=i("a",{id:"RadialBasisFunctions.∂²",href:"#RadialBasisFunctions.∂²"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∂²")],-1)),s[506]||(s[506]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[508]||(s[508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∂²{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Second partial derivative operator functor. Construct with <code>∂²(basis, dim)</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[507]||(s[507]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L33-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Oi,[i("summary",null,[s[509]||(s[509]=i("a",{id:"RadialBasisFunctions.∇",href:"#RadialBasisFunctions.∇"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∇")],-1)),s[510]||(s[510]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[512]||(s[512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∇{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Gradient operator functor. Construct with <code>∇(basis)</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[511]||(s[511]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L24-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ni,[i("summary",null,[s[513]||(s[513]=i("a",{id:"RadialBasisFunctions.∇²",href:"#RadialBasisFunctions.∇²"},[i("span",{class:"jlbinding"},"RadialBasisFunctions.∇²")],-1)),s[514]||(s[514]=l()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[516]||(s[516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">∇²{B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRadialBasis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Laplacian operator functor. Construct with <code>∇²(basis)</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:e(()=>[...s[515]||(s[515]=[i("a",{href:"https://github.com/JuliaMeshless/RadialBasisFunctions.jl/blob/3a5beb6b5f5605eba560105a22261b74ad39597d/src/basis/basis.jl#L43-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const qi=r(h,[["render",Ji]]);export{Qi as __pageData,qi as default};
